// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(nostrFFI)
import nostrFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_nostr_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_nostr_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




public protocol ContactProtocol : AnyObject {
    
    func alias()  -> String?
    
    func publicKey()  -> PublicKey
    
    func relayUrl()  -> String?
    
}
public class Contact:
    ContactProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_contact(self.pointer, $0) }
    }
    public convenience init(pk: PublicKey, relayUrl: String?, alias: String?)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_contact_new(
        FfiConverterTypePublicKey.lower(pk),
        FfiConverterOptionString.lower(relayUrl),
        FfiConverterOptionString.lower(alias),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_contact(pointer, $0) }
    }

    

    
    
    public func alias()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_contact_alias(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func publicKey()  -> PublicKey {
        return try!  FfiConverterTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_contact_public_key(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func relayUrl()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_contact_relay_url(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeContact: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Contact

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Contact {
        return Contact(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Contact) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Contact {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Contact, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeContact_lift(_ pointer: UnsafeMutableRawPointer) throws -> Contact {
    return try FfiConverterTypeContact.lift(pointer)
}

public func FfiConverterTypeContact_lower(_ value: Contact) -> UnsafeMutableRawPointer {
    return FfiConverterTypeContact.lower(value)
}




/**
 * Coordinate for event (`a` tag)
 */
public protocol CoordinateProtocol : AnyObject {
    
    func identifier()  -> String
    
    func kind()  -> UInt64
    
    func publicKey()  -> PublicKey
    
    func relays()  -> [String]
    
    func toBech32() throws  -> String
    
    func toNostrUri() throws  -> String
    
}
/**
 * Coordinate for event (`a` tag)
 */
public class Coordinate:
    CoordinateProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_coordinate(self.pointer, $0) }
    }
    public convenience init(kind: UInt64, publicKey: PublicKey)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_coordinate_new(
        FfiConverterUInt64.lower(kind),
        FfiConverterTypePublicKey.lower(publicKey),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_coordinate(pointer, $0) }
    }

    
    public static func fromBech32(bech32: String) throws  -> Coordinate {
        return Coordinate(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_coordinate_from_bech32(
        FfiConverterString.lower(bech32),$0)
})
    }

    
    public static func fromNostrUri(uri: String) throws  -> Coordinate {
        return Coordinate(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_coordinate_from_nostr_uri(
        FfiConverterString.lower(uri),$0)
})
    }

    
    public static func parse(coordinate: String) throws  -> Coordinate {
        return Coordinate(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_coordinate_parse(
        FfiConverterString.lower(coordinate),$0)
})
    }

    

    
    
    public func identifier()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_coordinate_identifier(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func kind()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_coordinate_kind(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func publicKey()  -> PublicKey {
        return try!  FfiConverterTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_coordinate_public_key(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func relays()  -> [String] {
        return try!  FfiConverterSequenceString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_coordinate_relays(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func toBech32() throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_coordinate_to_bech32(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func toNostrUri() throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_coordinate_to_nostr_uri(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeCoordinate: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Coordinate

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Coordinate {
        return Coordinate(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Coordinate) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Coordinate {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Coordinate, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeCoordinate_lift(_ pointer: UnsafeMutableRawPointer) throws -> Coordinate {
    return try FfiConverterTypeCoordinate.lift(pointer)
}

public func FfiConverterTypeCoordinate_lower(_ value: Coordinate) -> UnsafeMutableRawPointer {
    return FfiConverterTypeCoordinate.lower(value)
}




public protocol EventProtocol : AnyObject {
    
    func asJson()  -> String
    
    func content()  -> String
    
    /**
     * Extract coordinates from tags (`a` tag)
     */
    func coordinates()  -> [Coordinate]
    
    func createdAt()  -> Timestamp
    
    /**
     * Extract event IDs from tags (`e` tag)
     */
    func eventIds()  -> [EventId]
    
    /**
     * Get `Timestamp` expiration if set
     */
    func expiration()  -> Timestamp?
    
    func id()  -> EventId
    
    /**
     * Extract identifier (`d` tag), if exists.
     */
    func identifier()  -> String?
    
    /**
     * Check if event `Kind` is `Ephemeral`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    func isEphemeral()  -> Bool
    
    /**
     * Returns `true` if the event has an expiration tag that is expired.
     * If an event has no `Expiration` tag, then it will return `false`.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/40.md>
     */
    func isExpired()  -> Bool
    
    /**
     * Check if `Kind` is a NIP90 job request
     *
     * <https://github.com/nostr-protocol/nips/blob/master/90.md>
     */
    func isJobRequest()  -> Bool
    
    /**
     * Check if `Kind` is a NIP90 job result
     *
     * <https://github.com/nostr-protocol/nips/blob/master/90.md>
     */
    func isJobResult()  -> Bool
    
    /**
     * Check if event `Kind` is `Parameterized replaceable`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    func isParameterizedReplaceable()  -> Bool
    
    /**
     * Check if event `Kind` is `Regular`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    func isRegular()  -> Bool
    
    /**
     * Check if event `Kind` is `Replaceable`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    func isReplaceable()  -> Bool
    
    func kind()  -> UInt64
    
    func pubkey()  -> PublicKey
    
    /**
     * Extract public keys from tags (`p` tag)
     */
    func publicKeys()  -> [PublicKey]
    
    func signature()  -> String
    
    func tags()  -> [Tag]
    
    /**
     * Verify both `EventId` and `Signature`
     */
    func verify()  -> Bool
    
    /**
     * Verify if the `EventId` it's composed correctly
     */
    func verifyId() throws 
    
    /**
     * Verify only event `Signature`
     */
    func verifySignature() throws 
    
}
public class Event:
    EventProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_event(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_event(pointer, $0) }
    }

    
    public static func fromJson(json: String) throws  -> Event {
        return Event(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_event_from_json(
        FfiConverterString.lower(json),$0)
})
    }

    

    
    
    public func asJson()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_as_json(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func content()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_content(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Extract coordinates from tags (`a` tag)
     */
    public func coordinates()  -> [Coordinate] {
        return try!  FfiConverterSequenceTypeCoordinate.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_coordinates(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func createdAt()  -> Timestamp {
        return try!  FfiConverterTypeTimestamp.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_created_at(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Extract event IDs from tags (`e` tag)
     */
    public func eventIds()  -> [EventId] {
        return try!  FfiConverterSequenceTypeEventId.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_event_ids(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Get `Timestamp` expiration if set
     */
    public func expiration()  -> Timestamp? {
        return try!  FfiConverterOptionTypeTimestamp.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_expiration(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func id()  -> EventId {
        return try!  FfiConverterTypeEventId.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Extract identifier (`d` tag), if exists.
     */
    public func identifier()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_identifier(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Check if event `Kind` is `Ephemeral`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    public func isEphemeral()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_is_ephemeral(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Returns `true` if the event has an expiration tag that is expired.
     * If an event has no `Expiration` tag, then it will return `false`.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/40.md>
     */
    public func isExpired()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_is_expired(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Check if `Kind` is a NIP90 job request
     *
     * <https://github.com/nostr-protocol/nips/blob/master/90.md>
     */
    public func isJobRequest()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_is_job_request(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Check if `Kind` is a NIP90 job result
     *
     * <https://github.com/nostr-protocol/nips/blob/master/90.md>
     */
    public func isJobResult()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_is_job_result(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Check if event `Kind` is `Parameterized replaceable`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    public func isParameterizedReplaceable()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_is_parameterized_replaceable(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Check if event `Kind` is `Regular`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    public func isRegular()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_is_regular(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Check if event `Kind` is `Replaceable`
     *
     * <https://github.com/nostr-protocol/nips/blob/master/01.md>
     */
    public func isReplaceable()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_is_replaceable(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func kind()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_kind(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func pubkey()  -> PublicKey {
        return try!  FfiConverterTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_pubkey(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Extract public keys from tags (`p` tag)
     */
    public func publicKeys()  -> [PublicKey] {
        return try!  FfiConverterSequenceTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_public_keys(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func signature()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_signature(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func tags()  -> [Tag] {
        return try!  FfiConverterSequenceTypeTag.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_tags(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Verify both `EventId` and `Signature`
     */
    public func verify()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_event_verify(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Verify if the `EventId` it's composed correctly
     */
    public func verifyId() throws  {
        try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_event_verify_id(self.uniffiClonePointer(), $0
    )
}
    }
    /**
     * Verify only event `Signature`
     */
    public func verifySignature() throws  {
        try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_event_verify_signature(self.uniffiClonePointer(), $0
    )
}
    }

}

public struct FfiConverterTypeEvent: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Event

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Event {
        return Event(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Event) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Event {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Event, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeEvent_lift(_ pointer: UnsafeMutableRawPointer) throws -> Event {
    return try FfiConverterTypeEvent.lift(pointer)
}

public func FfiConverterTypeEvent_lower(_ value: Event) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEvent.lower(value)
}




public protocol EventBuilderProtocol : AnyObject {
    
    func toEvent(keys: Keys) throws  -> Event
    
    func toPowEvent(keys: Keys, difficulty: UInt8) throws  -> Event
    
    func toUnsignedEvent(publicKey: PublicKey)  -> UnsignedEvent
    
    func toUnsignedPowEvent(publicKey: PublicKey, difficulty: UInt8)  -> UnsignedEvent
    
}
public class EventBuilder:
    EventBuilderProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_eventbuilder(self.pointer, $0) }
    }
    public convenience init(kind: UInt64, content: String, tags: [Tag]) throws  {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_new(
        FfiConverterUInt64.lower(kind),
        FfiConverterString.lower(content),
        FfiConverterSequenceTypeTag.lower(tags),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_eventbuilder(pointer, $0) }
    }

    
    public static func addRecommendedRelay(url: String) throws  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_add_recommended_relay(
        FfiConverterString.lower(url),$0)
})
    }

    
    public static func auth(challenge: String, relayUrl: String) throws  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_auth(
        FfiConverterString.lower(challenge),
        FfiConverterString.lower(relayUrl),$0)
})
    }

    
    public static func awardBadge(badgeDefinition: Event, awardedPubkeys: [Tag]) throws  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_award_badge(
        FfiConverterTypeEvent.lower(badgeDefinition),
        FfiConverterSequenceTypeTag.lower(awardedPubkeys),$0)
})
    }

    
    public static func defineBadge(badgeId: String, name: String?, description: String?, image: String?, imageDimensions: ImageDimensions?, thumbnails: [Image])  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_define_badge(
        FfiConverterString.lower(badgeId),
        FfiConverterOptionString.lower(name),
        FfiConverterOptionString.lower(description),
        FfiConverterOptionString.lower(image),
        FfiConverterOptionTypeImageDimensions.lower(imageDimensions),
        FfiConverterSequenceTypeImage.lower(thumbnails),$0)
})
    }

    
    /**
     * Create delete event
     */
    public static func delete(ids: [EventId], reason: String?)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_delete(
        FfiConverterSequenceTypeEventId.lower(ids),
        FfiConverterOptionString.lower(reason),$0)
})
    }

    
    public static func fileMetadata(description: String, metadata: FileMetadata)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_file_metadata(
        FfiConverterString.lower(description),
        FfiConverterTypeFileMetadata.lower(metadata),$0)
})
    }

    
    public static func hideChannelMsg(messageId: EventId, reason: String?)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_hide_channel_msg(
        FfiConverterTypeEventId.lower(messageId),
        FfiConverterOptionString.lower(reason),$0)
})
    }

    
    public static func httpAuth(data: HttpData)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_http_auth(
        FfiConverterTypeHttpData.lower(data),$0)
})
    }

    
    public static func jobFeedback(jobRequest: Event, status: DataVendingMachineStatus, extraInfo: String?, amountMillisats: UInt64, bolt11: String?, payload: String?)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_job_feedback(
        FfiConverterTypeEvent.lower(jobRequest),
        FfiConverterTypeDataVendingMachineStatus.lower(status),
        FfiConverterOptionString.lower(extraInfo),
        FfiConverterUInt64.lower(amountMillisats),
        FfiConverterOptionString.lower(bolt11),
        FfiConverterOptionString.lower(payload),$0)
})
    }

    
    /**
     * Data Vending Machine - Job Request
     *
     * <https://github.com/nostr-protocol/nips/blob/master/90.md>
     */
    public static func jobRequest(kind: UInt64, tags: [Tag]) throws  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_job_request(
        FfiConverterUInt64.lower(kind),
        FfiConverterSequenceTypeTag.lower(tags),$0)
})
    }

    
    public static func jobResult(jobRequest: Event, amountMillisats: UInt64, bolt11: String?) throws  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_job_result(
        FfiConverterTypeEvent.lower(jobRequest),
        FfiConverterUInt64.lower(amountMillisats),
        FfiConverterOptionString.lower(bolt11),$0)
})
    }

    
    public static func liveEvent(liveEvent: LiveEvent)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_live_event(
        FfiConverterTypeLiveEvent.lower(liveEvent),$0)
})
    }

    
    public static func liveEventMsg(liveEventId: String, liveEventHost: PublicKey, content: String, relayUrl: String?, tags: [Tag]) throws  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_live_event_msg(
        FfiConverterString.lower(liveEventId),
        FfiConverterTypePublicKey.lower(liveEventHost),
        FfiConverterString.lower(content),
        FfiConverterOptionString.lower(relayUrl),
        FfiConverterSequenceTypeTag.lower(tags),$0)
})
    }

    
    public static func longFormTextNote(content: String, tags: [Tag]) throws  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_long_form_text_note(
        FfiConverterString.lower(content),
        FfiConverterSequenceTypeTag.lower(tags),$0)
})
    }

    
    public static func muteChannelUser(publicKey: PublicKey, reason: String?)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_mute_channel_user(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterOptionString.lower(reason),$0)
})
    }

    
    public static func newChannel(metadata: Metadata)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_new_channel(
        FfiConverterTypeMetadata.lower(metadata),$0)
})
    }

    
    public static func newChannelMsg(channelId: EventId, relayUrl: String, content: String) throws  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_new_channel_msg(
        FfiConverterTypeEventId.lower(channelId),
        FfiConverterString.lower(relayUrl),
        FfiConverterString.lower(content),$0)
})
    }

    
    /**
     * Create encrypted direct msg event
     */
    public static func newEncryptedDirectMsg(senderKeys: Keys, receiverPubkey: PublicKey, content: String, replyTo: EventId?) throws  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_new_encrypted_direct_msg(
        FfiConverterTypeKeys.lower(senderKeys),
        FfiConverterTypePublicKey.lower(receiverPubkey),
        FfiConverterString.lower(content),
        FfiConverterOptionTypeEventId.lower(replyTo),$0)
})
    }

    
    public static func newProductData(data: ProductData)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_new_product_data(
        FfiConverterTypeProductData.lower(data),$0)
})
    }

    
    public static func newReaction(eventId: EventId, publicKey: PublicKey, content: String)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_new_reaction(
        FfiConverterTypeEventId.lower(eventId),
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterString.lower(content),$0)
})
    }

    
    public static func newStallData(data: StallData)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_new_stall_data(
        FfiConverterTypeStallData.lower(data),$0)
})
    }

    
    public static func newTextNote(content: String, tags: [Tag]) throws  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_new_text_note(
        FfiConverterString.lower(content),
        FfiConverterSequenceTypeTag.lower(tags),$0)
})
    }

    
    public static func newZapReceipt(bolt11: String, preimage: String?, zapRequest: Event)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_new_zap_receipt(
        FfiConverterString.lower(bolt11),
        FfiConverterOptionString.lower(preimage),
        FfiConverterTypeEvent.lower(zapRequest),$0)
})
    }

    
    public static func nostrConnect(senderKeys: Keys, receiverPubkey: PublicKey, msg: NostrConnectMessage) throws  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_nostr_connect(
        FfiConverterTypeKeys.lower(senderKeys),
        FfiConverterTypePublicKey.lower(receiverPubkey),
        FfiConverterTypeNostrConnectMessage.lower(msg),$0)
})
    }

    
    public static func profileBadges(badgeDefinitions: [Event], badgeAwards: [Event], pubkeyAwarded: PublicKey) throws  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_profile_badges(
        FfiConverterSequenceTypeEvent.lower(badgeDefinitions),
        FfiConverterSequenceTypeEvent.lower(badgeAwards),
        FfiConverterTypePublicKey.lower(pubkeyAwarded),$0)
})
    }

    
    /**
     * Create **public** zap request event
     *
     * **This event MUST NOT be broadcasted to relays**, instead must be sent to a recipient's LNURL pay callback url.
     *
     * To build a **private** or **anonymous** zap request use `nip57_private_zap_request(...)` or `nip57_anonymous_zap_request(...)` functions.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/57.md>
     */
    public static func publicZapRequest(data: ZapRequestData)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_public_zap_request(
        FfiConverterTypeZapRequestData.lower(data),$0)
})
    }

    
    public static func relayList(list: [String: RelayMetadata?])  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_relay_list(
        FfiConverterDictionaryStringOptionTypeRelayMetadata.lower(list),$0)
})
    }

    
    public static func report(tags: [Tag], content: String)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_report(
        FfiConverterSequenceTypeTag.lower(tags),
        FfiConverterString.lower(content),$0)
})
    }

    
    public static func repost(eventId: EventId, publicKey: PublicKey)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_repost(
        FfiConverterTypeEventId.lower(eventId),
        FfiConverterTypePublicKey.lower(publicKey),$0)
})
    }

    
    public static func setChannelMetadata(channelId: EventId, relayUrl: String?, metadata: Metadata) throws  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_set_channel_metadata(
        FfiConverterTypeEventId.lower(channelId),
        FfiConverterOptionString.lower(relayUrl),
        FfiConverterTypeMetadata.lower(metadata),$0)
})
    }

    
    public static func setContactList(list: [Contact])  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_set_contact_list(
        FfiConverterSequenceTypeContact.lower(list),$0)
})
    }

    
    public static func setMetadata(metadata: Metadata)  -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_eventbuilder_set_metadata(
        FfiConverterTypeMetadata.lower(metadata),$0)
})
    }

    

    
    
    public func toEvent(keys: Keys) throws  -> Event {
        return try  FfiConverterTypeEvent.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_eventbuilder_to_event(self.uniffiClonePointer(), 
        FfiConverterTypeKeys.lower(keys),$0
    )
}
        )
    }
    public func toPowEvent(keys: Keys, difficulty: UInt8) throws  -> Event {
        return try  FfiConverterTypeEvent.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_eventbuilder_to_pow_event(self.uniffiClonePointer(), 
        FfiConverterTypeKeys.lower(keys),
        FfiConverterUInt8.lower(difficulty),$0
    )
}
        )
    }
    public func toUnsignedEvent(publicKey: PublicKey)  -> UnsignedEvent {
        return try!  FfiConverterTypeUnsignedEvent.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_event(self.uniffiClonePointer(), 
        FfiConverterTypePublicKey.lower(publicKey),$0
    )
}
        )
    }
    public func toUnsignedPowEvent(publicKey: PublicKey, difficulty: UInt8)  -> UnsignedEvent {
        return try!  FfiConverterTypeUnsignedEvent.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_eventbuilder_to_unsigned_pow_event(self.uniffiClonePointer(), 
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterUInt8.lower(difficulty),$0
    )
}
        )
    }

}

public struct FfiConverterTypeEventBuilder: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EventBuilder

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EventBuilder {
        return EventBuilder(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EventBuilder) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventBuilder {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EventBuilder, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeEventBuilder_lift(_ pointer: UnsafeMutableRawPointer) throws -> EventBuilder {
    return try FfiConverterTypeEventBuilder.lift(pointer)
}

public func FfiConverterTypeEventBuilder_lower(_ value: EventBuilder) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEventBuilder.lower(value)
}




public protocol EventIdProtocol : AnyObject {
    
    func asBytes()  -> Data
    
    func toBech32() throws  -> String
    
    func toHex()  -> String
    
    func toNostrUri() throws  -> String
    
}
public class EventId:
    EventIdProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_eventid(self.pointer, $0) }
    }
    public convenience init(pubkey: PublicKey, createdAt: Timestamp, kind: UInt64, tags: [[String]], content: String) throws  {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventid_new(
        FfiConverterTypePublicKey.lower(pubkey),
        FfiConverterTypeTimestamp.lower(createdAt),
        FfiConverterUInt64.lower(kind),
        FfiConverterSequenceSequenceString.lower(tags),
        FfiConverterString.lower(content),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_eventid(pointer, $0) }
    }

    
    public static func fromBech32(id: String) throws  -> EventId {
        return EventId(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventid_from_bech32(
        FfiConverterString.lower(id),$0)
})
    }

    
    public static func fromBytes(bytes: Data) throws  -> EventId {
        return EventId(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventid_from_bytes(
        FfiConverterData.lower(bytes),$0)
})
    }

    
    public static func fromHex(hex: String) throws  -> EventId {
        return EventId(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventid_from_hex(
        FfiConverterString.lower(hex),$0)
})
    }

    
    public static func fromNostrUri(uri: String) throws  -> EventId {
        return EventId(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_eventid_from_nostr_uri(
        FfiConverterString.lower(uri),$0)
})
    }

    

    
    
    public func asBytes()  -> Data {
        return try!  FfiConverterData.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_eventid_as_bytes(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func toBech32() throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_eventid_to_bech32(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func toHex()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_eventid_to_hex(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func toNostrUri() throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_eventid_to_nostr_uri(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeEventId: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EventId

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EventId {
        return EventId(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EventId) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventId {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EventId, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeEventId_lift(_ pointer: UnsafeMutableRawPointer) throws -> EventId {
    return try FfiConverterTypeEventId.lift(pointer)
}

public func FfiConverterTypeEventId_lower(_ value: EventId) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEventId.lower(value)
}




public protocol FileMetadataProtocol : AnyObject {
    
    func aes256Gcm(key: String, iv: String)  -> FileMetadata
    
    /**
     * Add blurhash
     */
    func blurhash(blurhash: String)  -> FileMetadata
    
    /**
     * Add file size (pixels)
     */
    func dimensions(dim: ImageDimensions)  -> FileMetadata
    
    /**
     * Add magnet
     */
    func magnet(magnet: String)  -> FileMetadata
    
    /**
     * Add file size (bytes)
     */
    func size(size: UInt64)  -> FileMetadata
    
}
public class FileMetadata:
    FileMetadataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_filemetadata(self.pointer, $0) }
    }
    public convenience init(url: String, mimeType: String, hash: String) throws  {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_filemetadata_new(
        FfiConverterString.lower(url),
        FfiConverterString.lower(mimeType),
        FfiConverterString.lower(hash),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_filemetadata(pointer, $0) }
    }

    

    
    
    public func aes256Gcm(key: String, iv: String)  -> FileMetadata {
        return try!  FfiConverterTypeFileMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filemetadata_aes_256_gcm(self.uniffiClonePointer(), 
        FfiConverterString.lower(key),
        FfiConverterString.lower(iv),$0
    )
}
        )
    }
    /**
     * Add blurhash
     */
    public func blurhash(blurhash: String)  -> FileMetadata {
        return try!  FfiConverterTypeFileMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filemetadata_blurhash(self.uniffiClonePointer(), 
        FfiConverterString.lower(blurhash),$0
    )
}
        )
    }
    /**
     * Add file size (pixels)
     */
    public func dimensions(dim: ImageDimensions)  -> FileMetadata {
        return try!  FfiConverterTypeFileMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filemetadata_dimensions(self.uniffiClonePointer(), 
        FfiConverterTypeImageDimensions.lower(dim),$0
    )
}
        )
    }
    /**
     * Add magnet
     */
    public func magnet(magnet: String)  -> FileMetadata {
        return try!  FfiConverterTypeFileMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filemetadata_magnet(self.uniffiClonePointer(), 
        FfiConverterString.lower(magnet),$0
    )
}
        )
    }
    /**
     * Add file size (bytes)
     */
    public func size(size: UInt64)  -> FileMetadata {
        return try!  FfiConverterTypeFileMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filemetadata_size(self.uniffiClonePointer(), 
        FfiConverterUInt64.lower(size),$0
    )
}
        )
    }

}

public struct FfiConverterTypeFileMetadata: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = FileMetadata

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> FileMetadata {
        return FileMetadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: FileMetadata) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileMetadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: FileMetadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeFileMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> FileMetadata {
    return try FfiConverterTypeFileMetadata.lift(pointer)
}

public func FfiConverterTypeFileMetadata_lower(_ value: FileMetadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFileMetadata.lower(value)
}




public protocol FilterProtocol : AnyObject {
    
    func asJson()  -> String
    
    /**
     * Add event author Public Key
     */
    func author(author: PublicKey)  -> Filter
    
    func authors(authors: [PublicKey])  -> Filter
    
    func customTag(tag: Alphabet, content: [String])  -> Filter
    
    /**
     * Add event ID (`e` tag)
     */
    func event(eventId: EventId)  -> Filter
    
    /**
     * Add event IDs (`e` tag)
     */
    func events(ids: [EventId])  -> Filter
    
    func hashtag(hashtag: String)  -> Filter
    
    func hashtags(hashtags: [String])  -> Filter
    
    func id(id: EventId)  -> Filter
    
    func identifier(identifier: String)  -> Filter
    
    func identifiers(identifiers: [String])  -> Filter
    
    func ids(ids: [EventId])  -> Filter
    
    func isEmpty()  -> Bool
    
    func kind(kind: UInt64)  -> Filter
    
    func kinds(kinds: [UInt64])  -> Filter
    
    func limit(limit: UInt64)  -> Filter
    
    /**
     * Add Public Key (`p` tag)
     */
    func pubkey(pubkey: PublicKey)  -> Filter
    
    /**
     * Add Public Keys (`p` tag)
     */
    func pubkeys(pubkeys: [PublicKey])  -> Filter
    
    func reference(reference: String)  -> Filter
    
    func references(references: [String])  -> Filter
    
    func removeAuthors(authors: [PublicKey])  -> Filter
    
    func removeCustomTag(tag: Alphabet, content: [String])  -> Filter
    
    func removeEvents(ids: [EventId])  -> Filter
    
    func removeHashtags(hashtags: [String])  -> Filter
    
    func removeIdentifiers(identifiers: [String])  -> Filter
    
    func removeIds(ids: [EventId])  -> Filter
    
    func removeKinds(kinds: [UInt64])  -> Filter
    
    func removeLimit()  -> Filter
    
    func removePubkeys(pubkeys: [PublicKey])  -> Filter
    
    func removeReferences(references: [String])  -> Filter
    
    func removeSearch()  -> Filter
    
    func removeSince()  -> Filter
    
    func removeUntil()  -> Filter
    
    func search(text: String)  -> Filter
    
    func since(timestamp: Timestamp)  -> Filter
    
    func until(timestamp: Timestamp)  -> Filter
    
}
public class Filter:
    FilterProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_filter(self.pointer, $0) }
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_filter_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_filter(pointer, $0) }
    }

    
    public static func fromJson(json: String) throws  -> Filter {
        return Filter(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_filter_from_json(
        FfiConverterString.lower(json),$0)
})
    }

    

    
    
    public func asJson()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_as_json(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Add event author Public Key
     */
    public func author(author: PublicKey)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_author(self.uniffiClonePointer(), 
        FfiConverterTypePublicKey.lower(author),$0
    )
}
        )
    }
    public func authors(authors: [PublicKey])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_authors(self.uniffiClonePointer(), 
        FfiConverterSequenceTypePublicKey.lower(authors),$0
    )
}
        )
    }
    public func customTag(tag: Alphabet, content: [String])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_custom_tag(self.uniffiClonePointer(), 
        FfiConverterTypeAlphabet.lower(tag),
        FfiConverterSequenceString.lower(content),$0
    )
}
        )
    }
    /**
     * Add event ID (`e` tag)
     */
    public func event(eventId: EventId)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_event(self.uniffiClonePointer(), 
        FfiConverterTypeEventId.lower(eventId),$0
    )
}
        )
    }
    /**
     * Add event IDs (`e` tag)
     */
    public func events(ids: [EventId])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_events(self.uniffiClonePointer(), 
        FfiConverterSequenceTypeEventId.lower(ids),$0
    )
}
        )
    }
    public func hashtag(hashtag: String)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_hashtag(self.uniffiClonePointer(), 
        FfiConverterString.lower(hashtag),$0
    )
}
        )
    }
    public func hashtags(hashtags: [String])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_hashtags(self.uniffiClonePointer(), 
        FfiConverterSequenceString.lower(hashtags),$0
    )
}
        )
    }
    public func id(id: EventId)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_id(self.uniffiClonePointer(), 
        FfiConverterTypeEventId.lower(id),$0
    )
}
        )
    }
    public func identifier(identifier: String)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_identifier(self.uniffiClonePointer(), 
        FfiConverterString.lower(identifier),$0
    )
}
        )
    }
    public func identifiers(identifiers: [String])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_identifiers(self.uniffiClonePointer(), 
        FfiConverterSequenceString.lower(identifiers),$0
    )
}
        )
    }
    public func ids(ids: [EventId])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_ids(self.uniffiClonePointer(), 
        FfiConverterSequenceTypeEventId.lower(ids),$0
    )
}
        )
    }
    public func isEmpty()  -> Bool {
        return try!  FfiConverterBool.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_is_empty(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func kind(kind: UInt64)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_kind(self.uniffiClonePointer(), 
        FfiConverterUInt64.lower(kind),$0
    )
}
        )
    }
    public func kinds(kinds: [UInt64])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_kinds(self.uniffiClonePointer(), 
        FfiConverterSequenceUInt64.lower(kinds),$0
    )
}
        )
    }
    public func limit(limit: UInt64)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_limit(self.uniffiClonePointer(), 
        FfiConverterUInt64.lower(limit),$0
    )
}
        )
    }
    /**
     * Add Public Key (`p` tag)
     */
    public func pubkey(pubkey: PublicKey)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_pubkey(self.uniffiClonePointer(), 
        FfiConverterTypePublicKey.lower(pubkey),$0
    )
}
        )
    }
    /**
     * Add Public Keys (`p` tag)
     */
    public func pubkeys(pubkeys: [PublicKey])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_pubkeys(self.uniffiClonePointer(), 
        FfiConverterSequenceTypePublicKey.lower(pubkeys),$0
    )
}
        )
    }
    public func reference(reference: String)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_reference(self.uniffiClonePointer(), 
        FfiConverterString.lower(reference),$0
    )
}
        )
    }
    public func references(references: [String])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_references(self.uniffiClonePointer(), 
        FfiConverterSequenceString.lower(references),$0
    )
}
        )
    }
    public func removeAuthors(authors: [PublicKey])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_remove_authors(self.uniffiClonePointer(), 
        FfiConverterSequenceTypePublicKey.lower(authors),$0
    )
}
        )
    }
    public func removeCustomTag(tag: Alphabet, content: [String])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_remove_custom_tag(self.uniffiClonePointer(), 
        FfiConverterTypeAlphabet.lower(tag),
        FfiConverterSequenceString.lower(content),$0
    )
}
        )
    }
    public func removeEvents(ids: [EventId])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_remove_events(self.uniffiClonePointer(), 
        FfiConverterSequenceTypeEventId.lower(ids),$0
    )
}
        )
    }
    public func removeHashtags(hashtags: [String])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_remove_hashtags(self.uniffiClonePointer(), 
        FfiConverterSequenceString.lower(hashtags),$0
    )
}
        )
    }
    public func removeIdentifiers(identifiers: [String])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_remove_identifiers(self.uniffiClonePointer(), 
        FfiConverterSequenceString.lower(identifiers),$0
    )
}
        )
    }
    public func removeIds(ids: [EventId])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_remove_ids(self.uniffiClonePointer(), 
        FfiConverterSequenceTypeEventId.lower(ids),$0
    )
}
        )
    }
    public func removeKinds(kinds: [UInt64])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_remove_kinds(self.uniffiClonePointer(), 
        FfiConverterSequenceUInt64.lower(kinds),$0
    )
}
        )
    }
    public func removeLimit()  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_remove_limit(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func removePubkeys(pubkeys: [PublicKey])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_remove_pubkeys(self.uniffiClonePointer(), 
        FfiConverterSequenceTypePublicKey.lower(pubkeys),$0
    )
}
        )
    }
    public func removeReferences(references: [String])  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_remove_references(self.uniffiClonePointer(), 
        FfiConverterSequenceString.lower(references),$0
    )
}
        )
    }
    public func removeSearch()  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_remove_search(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func removeSince()  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_remove_since(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func removeUntil()  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_remove_until(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func search(text: String)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_search(self.uniffiClonePointer(), 
        FfiConverterString.lower(text),$0
    )
}
        )
    }
    public func since(timestamp: Timestamp)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_since(self.uniffiClonePointer(), 
        FfiConverterTypeTimestamp.lower(timestamp),$0
    )
}
        )
    }
    public func until(timestamp: Timestamp)  -> Filter {
        return try!  FfiConverterTypeFilter.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_filter_until(self.uniffiClonePointer(), 
        FfiConverterTypeTimestamp.lower(timestamp),$0
    )
}
        )
    }

}

public struct FfiConverterTypeFilter: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Filter

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Filter {
        return Filter(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Filter) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Filter {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Filter, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeFilter_lift(_ pointer: UnsafeMutableRawPointer) throws -> Filter {
    return try FfiConverterTypeFilter.lift(pointer)
}

public func FfiConverterTypeFilter_lower(_ value: Filter) -> UnsafeMutableRawPointer {
    return FfiConverterTypeFilter.lower(value)
}




public protocol ImageDimensionsProtocol : AnyObject {
    
    func height()  -> UInt64
    
    func width()  -> UInt64
    
}
public class ImageDimensions:
    ImageDimensionsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_imagedimensions(self.pointer, $0) }
    }
    public convenience init(width: UInt64, height: UInt64)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_imagedimensions_new(
        FfiConverterUInt64.lower(width),
        FfiConverterUInt64.lower(height),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_imagedimensions(pointer, $0) }
    }

    

    
    
    public func height()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_imagedimensions_height(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func width()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_imagedimensions_width(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeImageDimensions: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ImageDimensions

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ImageDimensions {
        return ImageDimensions(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ImageDimensions) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImageDimensions {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ImageDimensions, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeImageDimensions_lift(_ pointer: UnsafeMutableRawPointer) throws -> ImageDimensions {
    return try FfiConverterTypeImageDimensions.lift(pointer)
}

public func FfiConverterTypeImageDimensions_lower(_ value: ImageDimensions) -> UnsafeMutableRawPointer {
    return FfiConverterTypeImageDimensions.lower(value)
}




public protocol KeysProtocol : AnyObject {
    
    func publicKey()  -> PublicKey
    
    func secretKey() throws  -> SecretKey
    
    func signSchnorr(message: Data) throws  -> String
    
}
public class Keys:
    KeysProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_keys(self.pointer, $0) }
    }
    public convenience init(sk: SecretKey)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_keys_new(
        FfiConverterTypeSecretKey.lower(sk),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_keys(pointer, $0) }
    }

    
    /**
     * Derive `Keys` from BIP-39 mnemonics (ENGLISH wordlist).
     *
     * By default no passphrase is used and account is set to `0`.
     *
     * <https://github.com/nostr-protocol/nips/blob/master/06.md>
     */
    public static func fromMnemonic(mnemonic: String, passphrase: String?, account: UInt32?) throws  -> Keys {
        return Keys(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_keys_from_mnemonic(
        FfiConverterString.lower(mnemonic),
        FfiConverterOptionString.lower(passphrase),
        FfiConverterOptionUInt32.lower(account),$0)
})
    }

    
    public static func fromPkStr(pk: String) throws  -> Keys {
        return Keys(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_keys_from_pk_str(
        FfiConverterString.lower(pk),$0)
})
    }

    
    public static func fromPublicKey(pk: PublicKey)  -> Keys {
        return Keys(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_keys_from_public_key(
        FfiConverterTypePublicKey.lower(pk),$0)
})
    }

    
    public static func fromSkStr(sk: String) throws  -> Keys {
        return Keys(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_keys_from_sk_str(
        FfiConverterString.lower(sk),$0)
})
    }

    
    public static func generate()  -> Keys {
        return Keys(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_keys_generate($0)
})
    }

    
    public static func vanity(prefixes: [String], bech32: Bool, numCores: UInt8) throws  -> Keys {
        return Keys(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_keys_vanity(
        FfiConverterSequenceString.lower(prefixes),
        FfiConverterBool.lower(bech32),
        FfiConverterUInt8.lower(numCores),$0)
})
    }

    

    
    
    public func publicKey()  -> PublicKey {
        return try!  FfiConverterTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_keys_public_key(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func secretKey() throws  -> SecretKey {
        return try  FfiConverterTypeSecretKey.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_keys_secret_key(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func signSchnorr(message: Data) throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_keys_sign_schnorr(self.uniffiClonePointer(), 
        FfiConverterData.lower(message),$0
    )
}
        )
    }

}

public struct FfiConverterTypeKeys: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Keys

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Keys {
        return Keys(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Keys) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Keys {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Keys, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeKeys_lift(_ pointer: UnsafeMutableRawPointer) throws -> Keys {
    return try FfiConverterTypeKeys.lift(pointer)
}

public func FfiConverterTypeKeys_lower(_ value: Keys) -> UnsafeMutableRawPointer {
    return FfiConverterTypeKeys.lower(value)
}




public protocol MetadataProtocol : AnyObject {
    
    func asJson()  -> String
    
    func getAbout()  -> String?
    
    func getBanner()  -> String?
    
    func getCustomField(key: String)  -> String?
    
    func getDisplayName()  -> String?
    
    func getLud06()  -> String?
    
    func getLud16()  -> String?
    
    func getName()  -> String?
    
    func getNip05()  -> String?
    
    func getPicture()  -> String?
    
    func getWebsite()  -> String?
    
    func setAbout(about: String)  -> Metadata
    
    func setBanner(banner: String) throws  -> Metadata
    
    func setCustomField(key: String, value: String)  -> Metadata
    
    func setDisplayName(displayName: String)  -> Metadata
    
    func setLud06(lud06: String)  -> Metadata
    
    func setLud16(lud16: String)  -> Metadata
    
    func setName(name: String)  -> Metadata
    
    func setNip05(nip05: String)  -> Metadata
    
    func setPicture(picture: String) throws  -> Metadata
    
    func setWebsite(website: String) throws  -> Metadata
    
}
public class Metadata:
    MetadataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_metadata(self.pointer, $0) }
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_metadata_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_metadata(pointer, $0) }
    }

    
    public static func fromJson(json: String) throws  -> Metadata {
        return Metadata(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_metadata_from_json(
        FfiConverterString.lower(json),$0)
})
    }

    

    
    
    public func asJson()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_metadata_as_json(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getAbout()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_metadata_get_about(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getBanner()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_metadata_get_banner(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getCustomField(key: String)  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_metadata_get_custom_field(self.uniffiClonePointer(), 
        FfiConverterString.lower(key),$0
    )
}
        )
    }
    public func getDisplayName()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_metadata_get_display_name(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getLud06()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_metadata_get_lud06(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getLud16()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_metadata_get_lud16(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getName()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_metadata_get_name(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getNip05()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_metadata_get_nip05(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getPicture()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_metadata_get_picture(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func getWebsite()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_metadata_get_website(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func setAbout(about: String)  -> Metadata {
        return try!  FfiConverterTypeMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_metadata_set_about(self.uniffiClonePointer(), 
        FfiConverterString.lower(about),$0
    )
}
        )
    }
    public func setBanner(banner: String) throws  -> Metadata {
        return try  FfiConverterTypeMetadata.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_metadata_set_banner(self.uniffiClonePointer(), 
        FfiConverterString.lower(banner),$0
    )
}
        )
    }
    public func setCustomField(key: String, value: String)  -> Metadata {
        return try!  FfiConverterTypeMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_metadata_set_custom_field(self.uniffiClonePointer(), 
        FfiConverterString.lower(key),
        FfiConverterString.lower(value),$0
    )
}
        )
    }
    public func setDisplayName(displayName: String)  -> Metadata {
        return try!  FfiConverterTypeMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_metadata_set_display_name(self.uniffiClonePointer(), 
        FfiConverterString.lower(displayName),$0
    )
}
        )
    }
    public func setLud06(lud06: String)  -> Metadata {
        return try!  FfiConverterTypeMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_metadata_set_lud06(self.uniffiClonePointer(), 
        FfiConverterString.lower(lud06),$0
    )
}
        )
    }
    public func setLud16(lud16: String)  -> Metadata {
        return try!  FfiConverterTypeMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_metadata_set_lud16(self.uniffiClonePointer(), 
        FfiConverterString.lower(lud16),$0
    )
}
        )
    }
    public func setName(name: String)  -> Metadata {
        return try!  FfiConverterTypeMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_metadata_set_name(self.uniffiClonePointer(), 
        FfiConverterString.lower(name),$0
    )
}
        )
    }
    public func setNip05(nip05: String)  -> Metadata {
        return try!  FfiConverterTypeMetadata.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_metadata_set_nip05(self.uniffiClonePointer(), 
        FfiConverterString.lower(nip05),$0
    )
}
        )
    }
    public func setPicture(picture: String) throws  -> Metadata {
        return try  FfiConverterTypeMetadata.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_metadata_set_picture(self.uniffiClonePointer(), 
        FfiConverterString.lower(picture),$0
    )
}
        )
    }
    public func setWebsite(website: String) throws  -> Metadata {
        return try  FfiConverterTypeMetadata.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_metadata_set_website(self.uniffiClonePointer(), 
        FfiConverterString.lower(website),$0
    )
}
        )
    }

}

public struct FfiConverterTypeMetadata: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Metadata

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Metadata {
        return Metadata(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Metadata) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Metadata {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Metadata, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeMetadata_lift(_ pointer: UnsafeMutableRawPointer) throws -> Metadata {
    return try FfiConverterTypeMetadata.lift(pointer)
}

public func FfiConverterTypeMetadata_lower(_ value: Metadata) -> UnsafeMutableRawPointer {
    return FfiConverterTypeMetadata.lower(value)
}




public protocol Nip19Protocol : AnyObject {
    
    func asEnum()  -> Nip19Enum
    
}
public class Nip19:
    Nip19Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_nip19(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_nip19(pointer, $0) }
    }

    
    public static func fromBech32(string: String) throws  -> Nip19 {
        return Nip19(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_nip19_from_bech32(
        FfiConverterString.lower(string),$0)
})
    }

    

    
    
    public func asEnum()  -> Nip19Enum {
        return try!  FfiConverterTypeNip19Enum.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_nip19_as_enum(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeNip19: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip19

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19 {
        return Nip19(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip19) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip19 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip19, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeNip19_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19 {
    return try FfiConverterTypeNip19.lift(pointer)
}

public func FfiConverterTypeNip19_lower(_ value: Nip19) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip19.lower(value)
}




public protocol Nip19EventProtocol : AnyObject {
    
    func author()  -> PublicKey?
    
    func eventId()  -> EventId
    
    func relays()  -> [String]
    
    func toBech32() throws  -> String
    
    func toNostrUri() throws  -> String
    
}
public class Nip19Event:
    Nip19EventProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_nip19event(self.pointer, $0) }
    }
    public convenience init(eventId: EventId, author: PublicKey?, relays: [String])  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_nip19event_new(
        FfiConverterTypeEventId.lower(eventId),
        FfiConverterOptionTypePublicKey.lower(author),
        FfiConverterSequenceString.lower(relays),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_nip19event(pointer, $0) }
    }

    
    public static func fromBech32(bech32: String) throws  -> Nip19Event {
        return Nip19Event(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_nip19event_from_bech32(
        FfiConverterString.lower(bech32),$0)
})
    }

    
    public static func fromNostrUri(uri: String) throws  -> Nip19Event {
        return Nip19Event(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_nip19event_from_nostr_uri(
        FfiConverterString.lower(uri),$0)
})
    }

    

    
    
    public func author()  -> PublicKey? {
        return try!  FfiConverterOptionTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_nip19event_author(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func eventId()  -> EventId {
        return try!  FfiConverterTypeEventId.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_nip19event_event_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func relays()  -> [String] {
        return try!  FfiConverterSequenceString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_nip19event_relays(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func toBech32() throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_nip19event_to_bech32(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func toNostrUri() throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_nip19event_to_nostr_uri(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeNip19Event: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip19Event

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19Event {
        return Nip19Event(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip19Event) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip19Event {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip19Event, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeNip19Event_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19Event {
    return try FfiConverterTypeNip19Event.lift(pointer)
}

public func FfiConverterTypeNip19Event_lower(_ value: Nip19Event) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip19Event.lower(value)
}




public protocol Nip19ProfileProtocol : AnyObject {
    
    func publicKey()  -> PublicKey
    
    func relays()  -> [String]
    
    func toBech32() throws  -> String
    
    func toNostrUri() throws  -> String
    
}
public class Nip19Profile:
    Nip19ProfileProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_nip19profile(self.pointer, $0) }
    }
    /**
     * New NIP19 profile
     */
    public convenience init(publicKey: PublicKey, relays: [String])  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_nip19profile_new(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterSequenceString.lower(relays),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_nip19profile(pointer, $0) }
    }

    
    public static func fromBech32(bech32: String) throws  -> Nip19Profile {
        return Nip19Profile(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_nip19profile_from_bech32(
        FfiConverterString.lower(bech32),$0)
})
    }

    
    public static func fromNostrUri(uri: String) throws  -> Nip19Profile {
        return Nip19Profile(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_nip19profile_from_nostr_uri(
        FfiConverterString.lower(uri),$0)
})
    }

    

    
    
    public func publicKey()  -> PublicKey {
        return try!  FfiConverterTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_nip19profile_public_key(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func relays()  -> [String] {
        return try!  FfiConverterSequenceString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_nip19profile_relays(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func toBech32() throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_nip19profile_to_bech32(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func toNostrUri() throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_nip19profile_to_nostr_uri(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeNip19Profile: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip19Profile

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19Profile {
        return Nip19Profile(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip19Profile) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip19Profile {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip19Profile, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeNip19Profile_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip19Profile {
    return try FfiConverterTypeNip19Profile.lift(pointer)
}

public func FfiConverterTypeNip19Profile_lower(_ value: Nip19Profile) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip19Profile.lower(value)
}




public protocol Nip21Protocol : AnyObject {
    
    func asEnum()  -> Nip21Enum
    
    /**
     * Serialize to NIP21 nostr URI
     */
    func toNostrUri() throws  -> String
    
}
public class Nip21:
    Nip21Protocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_nip21(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_nip21(pointer, $0) }
    }

    
    /**
     * Parse NIP21 string
     */
    public static func parse(uri: String) throws  -> Nip21 {
        return Nip21(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_nip21_parse(
        FfiConverterString.lower(uri),$0)
})
    }

    

    
    
    public func asEnum()  -> Nip21Enum {
        return try!  FfiConverterTypeNip21Enum.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_nip21_as_enum(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Serialize to NIP21 nostr URI
     */
    public func toNostrUri() throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_nip21_to_nostr_uri(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeNip21: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Nip21

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip21 {
        return Nip21(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Nip21) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip21 {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Nip21, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeNip21_lift(_ pointer: UnsafeMutableRawPointer) throws -> Nip21 {
    return try FfiConverterTypeNip21.lift(pointer)
}

public func FfiConverterTypeNip21_lower(_ value: Nip21) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNip21.lower(value)
}




public protocol NostrConnectUriProtocol : AnyObject {
    
    func description()  -> String?
    
    func name()  -> String
    
    func publicKey()  -> PublicKey
    
    func relayUrl()  -> String
    
    func url()  -> String?
    
}
public class NostrConnectUri:
    NostrConnectUriProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_nostrconnecturi(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_nostrconnecturi(pointer, $0) }
    }

    
    public static func fromString(uri: String) throws  -> NostrConnectUri {
        return NostrConnectUri(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_nostrconnecturi_from_string(
        FfiConverterString.lower(uri),$0)
})
    }

    

    
    
    public func description()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_nostrconnecturi_description(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func name()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_nostrconnecturi_name(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func publicKey()  -> PublicKey {
        return try!  FfiConverterTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_nostrconnecturi_public_key(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func relayUrl()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_nostrconnecturi_relay_url(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func url()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_nostrconnecturi_url(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeNostrConnectURI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrConnectUri

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectUri {
        return NostrConnectUri(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrConnectUri) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrConnectUri {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrConnectUri, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeNostrConnectURI_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrConnectUri {
    return try FfiConverterTypeNostrConnectURI.lift(pointer)
}

public func FfiConverterTypeNostrConnectURI_lower(_ value: NostrConnectUri) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrConnectURI.lower(value)
}




public protocol NostrLibraryProtocol : AnyObject {
    
    func gitHashVersion()  -> String
    
}
public class NostrLibrary:
    NostrLibraryProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_nostrlibrary(self.pointer, $0) }
    }
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_nostrlibrary_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_nostrlibrary(pointer, $0) }
    }

    

    
    
    public func gitHashVersion()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_nostrlibrary_git_hash_version(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeNostrLibrary: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrLibrary

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrLibrary {
        return NostrLibrary(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrLibrary) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrLibrary {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrLibrary, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeNostrLibrary_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrLibrary {
    return try FfiConverterTypeNostrLibrary.lift(pointer)
}

public func FfiConverterTypeNostrLibrary_lower(_ value: NostrLibrary) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrLibrary.lower(value)
}




/**
 * Nostr Connect URI
 */
public protocol NostrWalletConnectUriProtocol : AnyObject {
    
    /**
     * A lightning address that clients can use to automatically setup the lud16 field on the user's profile if they have none configured.
     */
    func lud16()  -> String?
    
    /**
     * App Pubkey
     */
    func publicKey()  -> PublicKey
    
    /**
     * URL of the relay of choice where the `App` is connected and the `Signer` must send and listen for messages.
     */
    func relayUrl()  -> String
    
    /**
     * 32-byte randomly generated hex encoded string
     */
    func secret()  -> SecretKey
    
}
/**
 * Nostr Connect URI
 */
public class NostrWalletConnectUri:
    NostrWalletConnectUriProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_nostrwalletconnecturi(self.pointer, $0) }
    }
    /**
     * Create new Nostr Wallet Connect URI
     */
    public convenience init(publicKey: PublicKey, relayUrl: String, randomSecretKey: SecretKey, lud16: String?) throws  {
        self.init(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_nostrwalletconnecturi_new(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterString.lower(relayUrl),
        FfiConverterTypeSecretKey.lower(randomSecretKey),
        FfiConverterOptionString.lower(lud16),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_nostrwalletconnecturi(pointer, $0) }
    }

    
    public static func parse(uri: String) throws  -> NostrWalletConnectUri {
        return NostrWalletConnectUri(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_nostrwalletconnecturi_parse(
        FfiConverterString.lower(uri),$0)
})
    }

    

    
    
    /**
     * A lightning address that clients can use to automatically setup the lud16 field on the user's profile if they have none configured.
     */
    public func lud16()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_lud16(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * App Pubkey
     */
    public func publicKey()  -> PublicKey {
        return try!  FfiConverterTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_public_key(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * URL of the relay of choice where the `App` is connected and the `Signer` must send and listen for messages.
     */
    public func relayUrl()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_relay_url(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * 32-byte randomly generated hex encoded string
     */
    public func secret()  -> SecretKey {
        return try!  FfiConverterTypeSecretKey.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_nostrwalletconnecturi_secret(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeNostrWalletConnectURI: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = NostrWalletConnectUri

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrWalletConnectUri {
        return NostrWalletConnectUri(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: NostrWalletConnectUri) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrWalletConnectUri {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: NostrWalletConnectUri, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeNostrWalletConnectURI_lift(_ pointer: UnsafeMutableRawPointer) throws -> NostrWalletConnectUri {
    return try FfiConverterTypeNostrWalletConnectURI.lift(pointer)
}

public func FfiConverterTypeNostrWalletConnectURI_lower(_ value: NostrWalletConnectUri) -> UnsafeMutableRawPointer {
    return FfiConverterTypeNostrWalletConnectURI.lower(value)
}




public protocol PublicKeyProtocol : AnyObject {
    
    func toBech32() throws  -> String
    
    func toHex()  -> String
    
    func toNostrUri() throws  -> String
    
}
public class PublicKey:
    PublicKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_publickey(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_publickey(pointer, $0) }
    }

    
    public static func fromBech32(pk: String) throws  -> PublicKey {
        return PublicKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_publickey_from_bech32(
        FfiConverterString.lower(pk),$0)
})
    }

    
    public static func fromBytes(bytes: Data) throws  -> PublicKey {
        return PublicKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_publickey_from_bytes(
        FfiConverterData.lower(bytes),$0)
})
    }

    
    public static func fromHex(hex: String) throws  -> PublicKey {
        return PublicKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_publickey_from_hex(
        FfiConverterString.lower(hex),$0)
})
    }

    
    public static func fromNostrUri(uri: String) throws  -> PublicKey {
        return PublicKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_publickey_from_nostr_uri(
        FfiConverterString.lower(uri),$0)
})
    }

    

    
    
    public func toBech32() throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_publickey_to_bech32(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func toHex()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_publickey_to_hex(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func toNostrUri() throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_publickey_to_nostr_uri(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypePublicKey: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = PublicKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> PublicKey {
        return PublicKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: PublicKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: PublicKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypePublicKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> PublicKey {
    return try FfiConverterTypePublicKey.lift(pointer)
}

public func FfiConverterTypePublicKey_lower(_ value: PublicKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypePublicKey.lower(value)
}




public protocol RelayInformationDocumentProtocol : AnyObject {
    
    func contact()  -> String?
    
    func description()  -> String?
    
    func fees()  -> FeeSchedules?
    
    func icon()  -> String?
    
    func languageTags()  -> [String]
    
    func limitation()  -> Limitation?
    
    func name()  -> String?
    
    func paymentsUrl()  -> String?
    
    func postingPolicy()  -> String?
    
    func pubkey()  -> String?
    
    func relayCountries()  -> [String]
    
    func retention()  -> [Retention]
    
    func software()  -> String?
    
    func supportedNips()  -> [UInt16]?
    
    func tags()  -> [String]
    
    func version()  -> String?
    
}
public class RelayInformationDocument:
    RelayInformationDocumentProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_relayinformationdocument(self.pointer, $0) }
    }
    /**
     * Create new empty [`RelayInformationDocument`]
     */
    public convenience init()  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_relayinformationdocument_new($0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_relayinformationdocument(pointer, $0) }
    }

    
    public static func get(url: String, proxy: String?) throws  -> RelayInformationDocument {
        return RelayInformationDocument(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_relayinformationdocument_get(
        FfiConverterString.lower(url),
        FfiConverterOptionString.lower(proxy),$0)
})
    }

    

    
    
    public func contact()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_relayinformationdocument_contact(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func description()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_relayinformationdocument_description(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func fees()  -> FeeSchedules? {
        return try!  FfiConverterOptionTypeFeeSchedules.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_relayinformationdocument_fees(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func icon()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_relayinformationdocument_icon(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func languageTags()  -> [String] {
        return try!  FfiConverterSequenceString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_relayinformationdocument_language_tags(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func limitation()  -> Limitation? {
        return try!  FfiConverterOptionTypeLimitation.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_relayinformationdocument_limitation(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func name()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_relayinformationdocument_name(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func paymentsUrl()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_relayinformationdocument_payments_url(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func postingPolicy()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_relayinformationdocument_posting_policy(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func pubkey()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_relayinformationdocument_pubkey(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func relayCountries()  -> [String] {
        return try!  FfiConverterSequenceString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_relayinformationdocument_relay_countries(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func retention()  -> [Retention] {
        return try!  FfiConverterSequenceTypeRetention.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_relayinformationdocument_retention(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func software()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_relayinformationdocument_software(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func supportedNips()  -> [UInt16]? {
        return try!  FfiConverterOptionSequenceUInt16.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_relayinformationdocument_supported_nips(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func tags()  -> [String] {
        return try!  FfiConverterSequenceString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_relayinformationdocument_tags(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func version()  -> String? {
        return try!  FfiConverterOptionString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_relayinformationdocument_version(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeRelayInformationDocument: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = RelayInformationDocument

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayInformationDocument {
        return RelayInformationDocument(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: RelayInformationDocument) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayInformationDocument {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: RelayInformationDocument, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeRelayInformationDocument_lift(_ pointer: UnsafeMutableRawPointer) throws -> RelayInformationDocument {
    return try FfiConverterTypeRelayInformationDocument.lift(pointer)
}

public func FfiConverterTypeRelayInformationDocument_lower(_ value: RelayInformationDocument) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRelayInformationDocument.lower(value)
}




/**
 * NIP47 Request
 */
public protocol RequestProtocol : AnyObject {
    
    func method()  -> Method
    
    func params()  -> RequestParams
    
}
/**
 * NIP47 Request
 */
public class Request:
    RequestProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_request(self.pointer, $0) }
    }
    public convenience init(method: Method, params: RequestParams)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_request_new(
        FfiConverterTypeMethod.lower(method),
        FfiConverterTypeRequestParams.lower(params),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_request(pointer, $0) }
    }

    
    public static func parse(json: String) throws  -> Request {
        return Request(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_request_parse(
        FfiConverterString.lower(json),$0)
})
    }

    

    
    
    public func method()  -> Method {
        return try!  FfiConverterTypeMethod.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_request_method(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func params()  -> RequestParams {
        return try!  FfiConverterTypeRequestParams.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_request_params(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeRequest: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Request

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Request {
        return Request(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Request) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Request {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Request, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeRequest_lift(_ pointer: UnsafeMutableRawPointer) throws -> Request {
    return try FfiConverterTypeRequest.lift(pointer)
}

public func FfiConverterTypeRequest_lower(_ value: Request) -> UnsafeMutableRawPointer {
    return FfiConverterTypeRequest.lower(value)
}




/**
 * NIP47 Response
 */
public protocol ResponseProtocol : AnyObject {
    
}
/**
 * NIP47 Response
 */
public class Response:
    ResponseProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_response(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_response(pointer, $0) }
    }

    

    
    

}

public struct FfiConverterTypeResponse: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Response

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Response {
        return Response(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Response) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Response {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Response, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeResponse_lift(_ pointer: UnsafeMutableRawPointer) throws -> Response {
    return try FfiConverterTypeResponse.lift(pointer)
}

public func FfiConverterTypeResponse_lower(_ value: Response) -> UnsafeMutableRawPointer {
    return FfiConverterTypeResponse.lower(value)
}




public protocol SecretKeyProtocol : AnyObject {
    
    func toBech32() throws  -> String
    
    func toHex()  -> String
    
}
public class SecretKey:
    SecretKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_secretkey(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_secretkey(pointer, $0) }
    }

    
    public static func fromBech32(sk: String) throws  -> SecretKey {
        return SecretKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_secretkey_from_bech32(
        FfiConverterString.lower(sk),$0)
})
    }

    
    public static func fromBytes(bytes: Data) throws  -> SecretKey {
        return SecretKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_secretkey_from_bytes(
        FfiConverterData.lower(bytes),$0)
})
    }

    
    public static func fromHex(hex: String) throws  -> SecretKey {
        return SecretKey(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_secretkey_from_hex(
        FfiConverterString.lower(hex),$0)
})
    }

    

    
    
    public func toBech32() throws  -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_secretkey_to_bech32(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func toHex()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_secretkey_to_hex(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeSecretKey: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = SecretKey

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> SecretKey {
        return SecretKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: SecretKey) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecretKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: SecretKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeSecretKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> SecretKey {
    return try FfiConverterTypeSecretKey.lift(pointer)
}

public func FfiConverterTypeSecretKey_lower(_ value: SecretKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeSecretKey.lower(value)
}




public protocol ShippingMethodProtocol : AnyObject {
    
    /**
     * Get the product shipping cost of the shipping method
     */
    func getShippingCost()  -> ShippingCost
    
    /**
     * Set the name of the shipping method
     */
    func name(name: String)  -> ShippingMethod
    
    /**
     * Add a region to the shipping method
     */
    func regions(regions: [String])  -> ShippingMethod
    
}
public class ShippingMethod:
    ShippingMethodProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_shippingmethod(self.pointer, $0) }
    }
    /**
     * Create a new shipping method
     */
    public convenience init(id: String, cost: Double)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_shippingmethod_new(
        FfiConverterString.lower(id),
        FfiConverterDouble.lower(cost),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_shippingmethod(pointer, $0) }
    }

    

    
    
    /**
     * Get the product shipping cost of the shipping method
     */
    public func getShippingCost()  -> ShippingCost {
        return try!  FfiConverterTypeShippingCost.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_shippingmethod_get_shipping_cost(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Set the name of the shipping method
     */
    public func name(name: String)  -> ShippingMethod {
        return try!  FfiConverterTypeShippingMethod.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_shippingmethod_name(self.uniffiClonePointer(), 
        FfiConverterString.lower(name),$0
    )
}
        )
    }
    /**
     * Add a region to the shipping method
     */
    public func regions(regions: [String])  -> ShippingMethod {
        return try!  FfiConverterTypeShippingMethod.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_shippingmethod_regions(self.uniffiClonePointer(), 
        FfiConverterSequenceString.lower(regions),$0
    )
}
        )
    }

}

public struct FfiConverterTypeShippingMethod: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ShippingMethod

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ShippingMethod {
        return ShippingMethod(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ShippingMethod) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShippingMethod {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ShippingMethod, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeShippingMethod_lift(_ pointer: UnsafeMutableRawPointer) throws -> ShippingMethod {
    return try FfiConverterTypeShippingMethod.lift(pointer)
}

public func FfiConverterTypeShippingMethod_lower(_ value: ShippingMethod) -> UnsafeMutableRawPointer {
    return FfiConverterTypeShippingMethod.lower(value)
}




public protocol TagProtocol : AnyObject {
    
    func asEnum()  -> TagEnum
    
    func asVec()  -> [String]
    
    func kind()  -> TagKind
    
}
public class Tag:
    TagProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_tag(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_tag(pointer, $0) }
    }

    
    /**
     * Compose `["e", "<event-id>"]` tag
     */
    public static func event(eventId: EventId)  -> Tag {
        return Tag(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_tag_event(
        FfiConverterTypeEventId.lower(eventId),$0)
})
    }

    
    public static func fromEnum(e: TagEnum) throws  -> Tag {
        return Tag(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_tag_from_enum(
        FfiConverterTypeTagEnum.lower(e),$0)
})
    }

    
    public static func parse(data: [String]) throws  -> Tag {
        return Tag(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_tag_parse(
        FfiConverterSequenceString.lower(data),$0)
})
    }

    
    /**
     * Compose `["p", "<public-key>"]` tag
     */
    public static func publicKey(publicKey: PublicKey)  -> Tag {
        return Tag(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_tag_public_key(
        FfiConverterTypePublicKey.lower(publicKey),$0)
})
    }

    

    
    
    public func asEnum()  -> TagEnum {
        return try!  FfiConverterTypeTagEnum.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_tag_as_enum(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func asVec()  -> [String] {
        return try!  FfiConverterSequenceString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_tag_as_vec(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func kind()  -> TagKind {
        return try!  FfiConverterTypeTagKind.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_tag_kind(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeTag: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Tag

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Tag {
        return Tag(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Tag) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Tag {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Tag, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeTag_lift(_ pointer: UnsafeMutableRawPointer) throws -> Tag {
    return try FfiConverterTypeTag.lift(pointer)
}

public func FfiConverterTypeTag_lower(_ value: Tag) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTag.lower(value)
}




public protocol TimestampProtocol : AnyObject {
    
    /**
     * Get timestamp as [`u64`]
     */
    func asSecs()  -> UInt64
    
    /**
     * Convert [`Timestamp`] to human datetime
     */
    func toHumanDatetime()  -> String
    
}
public class Timestamp:
    TimestampProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_timestamp(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_timestamp(pointer, $0) }
    }

    
    public static func fromSecs(secs: UInt64)  -> Timestamp {
        return Timestamp(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_timestamp_from_secs(
        FfiConverterUInt64.lower(secs),$0)
})
    }

    
    /**
     * Get UNIX timestamp
     */
    public static func now()  -> Timestamp {
        return Timestamp(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_timestamp_now($0)
})
    }

    
    public static func tweaked()  -> Timestamp {
        return Timestamp(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_timestamp_tweaked($0)
})
    }

    

    
    
    /**
     * Get timestamp as [`u64`]
     */
    public func asSecs()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_timestamp_as_secs(self.uniffiClonePointer(), $0
    )
}
        )
    }
    /**
     * Convert [`Timestamp`] to human datetime
     */
    public func toHumanDatetime()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_timestamp_to_human_datetime(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeTimestamp: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Timestamp

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Timestamp {
        return Timestamp(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Timestamp) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Timestamp {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Timestamp, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeTimestamp_lift(_ pointer: UnsafeMutableRawPointer) throws -> Timestamp {
    return try FfiConverterTypeTimestamp.lift(pointer)
}

public func FfiConverterTypeTimestamp_lower(_ value: Timestamp) -> UnsafeMutableRawPointer {
    return FfiConverterTypeTimestamp.lower(value)
}




public protocol UnsignedEventProtocol : AnyObject {
    
    /**
     * Add signature to [`UnsignedEvent`]
     */
    func addSignature(sig: String) throws  -> Event
    
    func asJson()  -> String
    
    func content()  -> String
    
    func createdAt()  -> Timestamp
    
    func id()  -> EventId
    
    func kind()  -> UInt64
    
    func pubkey()  -> PublicKey
    
    func sign(keys: Keys) throws  -> Event
    
    func tags()  -> [Tag]
    
}
public class UnsignedEvent:
    UnsignedEventProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_unsignedevent(self.pointer, $0) }
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_unsignedevent(pointer, $0) }
    }

    
    public static func fromJson(json: String) throws  -> UnsignedEvent {
        return UnsignedEvent(unsafeFromRawPointer: try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_constructor_unsignedevent_from_json(
        FfiConverterString.lower(json),$0)
})
    }

    

    
    
    /**
     * Add signature to [`UnsignedEvent`]
     */
    public func addSignature(sig: String) throws  -> Event {
        return try  FfiConverterTypeEvent.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_unsignedevent_add_signature(self.uniffiClonePointer(), 
        FfiConverterString.lower(sig),$0
    )
}
        )
    }
    public func asJson()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_unsignedevent_as_json(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func content()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_unsignedevent_content(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func createdAt()  -> Timestamp {
        return try!  FfiConverterTypeTimestamp.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_unsignedevent_created_at(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func id()  -> EventId {
        return try!  FfiConverterTypeEventId.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_unsignedevent_id(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func kind()  -> UInt64 {
        return try!  FfiConverterUInt64.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_unsignedevent_kind(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func pubkey()  -> PublicKey {
        return try!  FfiConverterTypePublicKey.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_unsignedevent_pubkey(self.uniffiClonePointer(), $0
    )
}
        )
    }
    public func sign(keys: Keys) throws  -> Event {
        return try  FfiConverterTypeEvent.lift(
            try 
    rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_method_unsignedevent_sign(self.uniffiClonePointer(), 
        FfiConverterTypeKeys.lower(keys),$0
    )
}
        )
    }
    public func tags()  -> [Tag] {
        return try!  FfiConverterSequenceTypeTag.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_unsignedevent_tags(self.uniffiClonePointer(), $0
    )
}
        )
    }

}

public struct FfiConverterTypeUnsignedEvent: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = UnsignedEvent

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsignedEvent {
        return UnsignedEvent(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: UnsignedEvent) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnsignedEvent {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: UnsignedEvent, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeUnsignedEvent_lift(_ pointer: UnsafeMutableRawPointer) throws -> UnsignedEvent {
    return try FfiConverterTypeUnsignedEvent.lift(pointer)
}

public func FfiConverterTypeUnsignedEvent_lower(_ value: UnsignedEvent) -> UnsafeMutableRawPointer {
    return FfiConverterTypeUnsignedEvent.lower(value)
}




public protocol ZapRequestDataProtocol : AnyObject {
    
    func amount(amount: UInt64)  -> ZapRequestData
    
    func eventId(eventId: EventId)  -> ZapRequestData
    
    func lnurl(lnurl: String)  -> ZapRequestData
    
    func message(message: String)  -> ZapRequestData
    
}
public class ZapRequestData:
    ZapRequestDataProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_nostr_ffi_fn_clone_zaprequestdata(self.pointer, $0) }
    }
    public convenience init(publicKey: PublicKey, relays: [String])  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_nostr_ffi_fn_constructor_zaprequestdata_new(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterSequenceString.lower(relays),$0)
})
    }

    deinit {
        try! rustCall { uniffi_nostr_ffi_fn_free_zaprequestdata(pointer, $0) }
    }

    

    
    
    public func amount(amount: UInt64)  -> ZapRequestData {
        return try!  FfiConverterTypeZapRequestData.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_zaprequestdata_amount(self.uniffiClonePointer(), 
        FfiConverterUInt64.lower(amount),$0
    )
}
        )
    }
    public func eventId(eventId: EventId)  -> ZapRequestData {
        return try!  FfiConverterTypeZapRequestData.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_zaprequestdata_event_id(self.uniffiClonePointer(), 
        FfiConverterTypeEventId.lower(eventId),$0
    )
}
        )
    }
    public func lnurl(lnurl: String)  -> ZapRequestData {
        return try!  FfiConverterTypeZapRequestData.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_zaprequestdata_lnurl(self.uniffiClonePointer(), 
        FfiConverterString.lower(lnurl),$0
    )
}
        )
    }
    public func message(message: String)  -> ZapRequestData {
        return try!  FfiConverterTypeZapRequestData.lift(
            try! 
    rustCall() {
    
    uniffi_nostr_ffi_fn_method_zaprequestdata_message(self.uniffiClonePointer(), 
        FfiConverterString.lower(message),$0
    )
}
        )
    }

}

public struct FfiConverterTypeZapRequestData: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = ZapRequestData

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapRequestData {
        return ZapRequestData(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: ZapRequestData) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ZapRequestData {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: ZapRequestData, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}


public func FfiConverterTypeZapRequestData_lift(_ pointer: UnsafeMutableRawPointer) throws -> ZapRequestData {
    return try FfiConverterTypeZapRequestData.lift(pointer)
}

public func FfiConverterTypeZapRequestData_lower(_ value: ZapRequestData) -> UnsafeMutableRawPointer {
    return FfiConverterTypeZapRequestData.lower(value)
}


/**
 * The specific information about a fee schedule
 */
public struct FeeSchedule {
    /**
     * The fee amount
     */
    public var amount: Int32
    /**
     * The denomination of the feed
     */
    public var unit: String
    /**
     * The duration for which the fee is valid
     */
    public var period: Int32?
    /**
     * The event kinds the fee allows the client to publish to the relay
     */
    public var kinds: [String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The fee amount
         */
        amount: Int32, 
        /**
         * The denomination of the feed
         */
        unit: String, 
        /**
         * The duration for which the fee is valid
         */
        period: Int32?, 
        /**
         * The event kinds the fee allows the client to publish to the relay
         */
        kinds: [String]?) {
        self.amount = amount
        self.unit = unit
        self.period = period
        self.kinds = kinds
    }
}


extension FeeSchedule: Equatable, Hashable {
    public static func ==(lhs: FeeSchedule, rhs: FeeSchedule) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.unit != rhs.unit {
            return false
        }
        if lhs.period != rhs.period {
            return false
        }
        if lhs.kinds != rhs.kinds {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
        hasher.combine(unit)
        hasher.combine(period)
        hasher.combine(kinds)
    }
}


public struct FfiConverterTypeFeeSchedule: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeSchedule {
        return
            try FeeSchedule(
                amount: FfiConverterInt32.read(from: &buf), 
                unit: FfiConverterString.read(from: &buf), 
                period: FfiConverterOptionInt32.read(from: &buf), 
                kinds: FfiConverterOptionSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: FeeSchedule, into buf: inout [UInt8]) {
        FfiConverterInt32.write(value.amount, into: &buf)
        FfiConverterString.write(value.unit, into: &buf)
        FfiConverterOptionInt32.write(value.period, into: &buf)
        FfiConverterOptionSequenceString.write(value.kinds, into: &buf)
    }
}


public func FfiConverterTypeFeeSchedule_lift(_ buf: RustBuffer) throws -> FeeSchedule {
    return try FfiConverterTypeFeeSchedule.lift(buf)
}

public func FfiConverterTypeFeeSchedule_lower(_ value: FeeSchedule) -> RustBuffer {
    return FfiConverterTypeFeeSchedule.lower(value)
}


/**
 * Available fee schedules
 */
public struct FeeSchedules {
    /**
     * Fees for admission to use the relay
     */
    public var admission: [FeeSchedule]
    /**
     * Fees for subscription to use the relay
     */
    public var subscription: [FeeSchedule]
    /**
     * Fees to publish to the relay
     */
    public var publication: [FeeSchedule]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Fees for admission to use the relay
         */
        admission: [FeeSchedule], 
        /**
         * Fees for subscription to use the relay
         */
        subscription: [FeeSchedule], 
        /**
         * Fees to publish to the relay
         */
        publication: [FeeSchedule]) {
        self.admission = admission
        self.subscription = subscription
        self.publication = publication
    }
}


extension FeeSchedules: Equatable, Hashable {
    public static func ==(lhs: FeeSchedules, rhs: FeeSchedules) -> Bool {
        if lhs.admission != rhs.admission {
            return false
        }
        if lhs.subscription != rhs.subscription {
            return false
        }
        if lhs.publication != rhs.publication {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(admission)
        hasher.combine(subscription)
        hasher.combine(publication)
    }
}


public struct FfiConverterTypeFeeSchedules: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FeeSchedules {
        return
            try FeeSchedules(
                admission: FfiConverterSequenceTypeFeeSchedule.read(from: &buf), 
                subscription: FfiConverterSequenceTypeFeeSchedule.read(from: &buf), 
                publication: FfiConverterSequenceTypeFeeSchedule.read(from: &buf)
        )
    }

    public static func write(_ value: FeeSchedules, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeFeeSchedule.write(value.admission, into: &buf)
        FfiConverterSequenceTypeFeeSchedule.write(value.subscription, into: &buf)
        FfiConverterSequenceTypeFeeSchedule.write(value.publication, into: &buf)
    }
}


public func FfiConverterTypeFeeSchedules_lift(_ buf: RustBuffer) throws -> FeeSchedules {
    return try FfiConverterTypeFeeSchedules.lift(buf)
}

public func FfiConverterTypeFeeSchedules_lower(_ value: FeeSchedules) -> RustBuffer {
    return FfiConverterTypeFeeSchedules.lower(value)
}


/**
 * NIP47 Response Result
 */
public struct GetBalanceResponseResult {
    /**
     * Balance amount in sats
     */
    public var balance: UInt64
    /**
     * Max amount payable within current budget
     */
    public var maxAmount: UInt64?
    /**
     * Budget renewal type
     */
    public var budgetRenewal: BudgetType?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Balance amount in sats
         */
        balance: UInt64, 
        /**
         * Max amount payable within current budget
         */
        maxAmount: UInt64?, 
        /**
         * Budget renewal type
         */
        budgetRenewal: BudgetType?) {
        self.balance = balance
        self.maxAmount = maxAmount
        self.budgetRenewal = budgetRenewal
    }
}


extension GetBalanceResponseResult: Equatable, Hashable {
    public static func ==(lhs: GetBalanceResponseResult, rhs: GetBalanceResponseResult) -> Bool {
        if lhs.balance != rhs.balance {
            return false
        }
        if lhs.maxAmount != rhs.maxAmount {
            return false
        }
        if lhs.budgetRenewal != rhs.budgetRenewal {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(balance)
        hasher.combine(maxAmount)
        hasher.combine(budgetRenewal)
    }
}


public struct FfiConverterTypeGetBalanceResponseResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetBalanceResponseResult {
        return
            try GetBalanceResponseResult(
                balance: FfiConverterUInt64.read(from: &buf), 
                maxAmount: FfiConverterOptionUInt64.read(from: &buf), 
                budgetRenewal: FfiConverterOptionTypeBudgetType.read(from: &buf)
        )
    }

    public static func write(_ value: GetBalanceResponseResult, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.balance, into: &buf)
        FfiConverterOptionUInt64.write(value.maxAmount, into: &buf)
        FfiConverterOptionTypeBudgetType.write(value.budgetRenewal, into: &buf)
    }
}


public func FfiConverterTypeGetBalanceResponseResult_lift(_ buf: RustBuffer) throws -> GetBalanceResponseResult {
    return try FfiConverterTypeGetBalanceResponseResult.lift(buf)
}

public func FfiConverterTypeGetBalanceResponseResult_lower(_ value: GetBalanceResponseResult) -> RustBuffer {
    return FfiConverterTypeGetBalanceResponseResult.lower(value)
}


public struct HttpData {
    public var url: String
    public var method: HttpMethod
    public var payload: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        url: String, 
        method: HttpMethod, 
        payload: String?) {
        self.url = url
        self.method = method
        self.payload = payload
    }
}


extension HttpData: Equatable, Hashable {
    public static func ==(lhs: HttpData, rhs: HttpData) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        if lhs.payload != rhs.payload {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(method)
        hasher.combine(payload)
    }
}


public struct FfiConverterTypeHttpData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpData {
        return
            try HttpData(
                url: FfiConverterString.read(from: &buf), 
                method: FfiConverterTypeHttpMethod.read(from: &buf), 
                payload: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: HttpData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterTypeHttpMethod.write(value.method, into: &buf)
        FfiConverterOptionString.write(value.payload, into: &buf)
    }
}


public func FfiConverterTypeHttpData_lift(_ buf: RustBuffer) throws -> HttpData {
    return try FfiConverterTypeHttpData.lift(buf)
}

public func FfiConverterTypeHttpData_lower(_ value: HttpData) -> RustBuffer {
    return FfiConverterTypeHttpData.lower(value)
}


/**
 * A NIP-39 external identity
 */
public struct Identity {
    /**
     * The external identity provider
     */
    public var platform: ExternalIdentity
    /**
     * The user's identity (username) on the provider
     */
    public var ident: String
    /**
     * The user's proof on the provider
     */
    public var proof: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The external identity provider
         */
        platform: ExternalIdentity, 
        /**
         * The user's identity (username) on the provider
         */
        ident: String, 
        /**
         * The user's proof on the provider
         */
        proof: String) {
        self.platform = platform
        self.ident = ident
        self.proof = proof
    }
}


extension Identity: Equatable, Hashable {
    public static func ==(lhs: Identity, rhs: Identity) -> Bool {
        if lhs.platform != rhs.platform {
            return false
        }
        if lhs.ident != rhs.ident {
            return false
        }
        if lhs.proof != rhs.proof {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(platform)
        hasher.combine(ident)
        hasher.combine(proof)
    }
}


public struct FfiConverterTypeIdentity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Identity {
        return
            try Identity(
                platform: FfiConverterTypeExternalIdentity.read(from: &buf), 
                ident: FfiConverterString.read(from: &buf), 
                proof: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Identity, into buf: inout [UInt8]) {
        FfiConverterTypeExternalIdentity.write(value.platform, into: &buf)
        FfiConverterString.write(value.ident, into: &buf)
        FfiConverterString.write(value.proof, into: &buf)
    }
}


public func FfiConverterTypeIdentity_lift(_ buf: RustBuffer) throws -> Identity {
    return try FfiConverterTypeIdentity.lift(buf)
}

public func FfiConverterTypeIdentity_lower(_ value: Identity) -> RustBuffer {
    return FfiConverterTypeIdentity.lower(value)
}


public struct Image {
    public var url: String
    public var dimensions: ImageDimensions?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        url: String, 
        dimensions: ImageDimensions?) {
        self.url = url
        self.dimensions = dimensions
    }
}



public struct FfiConverterTypeImage: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Image {
        return
            try Image(
                url: FfiConverterString.read(from: &buf), 
                dimensions: FfiConverterOptionTypeImageDimensions.read(from: &buf)
        )
    }

    public static func write(_ value: Image, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterOptionTypeImageDimensions.write(value.dimensions, into: &buf)
    }
}


public func FfiConverterTypeImage_lift(_ buf: RustBuffer) throws -> Image {
    return try FfiConverterTypeImage.lift(buf)
}

public func FfiConverterTypeImage_lower(_ value: Image) -> RustBuffer {
    return FfiConverterTypeImage.lower(value)
}


/**
 * TLVs to be added to the keysend payment
 */
public struct KeysendTlvRecord {
    /**
     * TLV type
     */
    public var type: UInt64
    /**
     * TLV value
     */
    public var value: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * TLV type
         */
        type: UInt64, 
        /**
         * TLV value
         */
        value: String) {
        self.type = type
        self.value = value
    }
}


extension KeysendTlvRecord: Equatable, Hashable {
    public static func ==(lhs: KeysendTlvRecord, rhs: KeysendTlvRecord) -> Bool {
        if lhs.type != rhs.type {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(type)
        hasher.combine(value)
    }
}


public struct FfiConverterTypeKeysendTLVRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeysendTlvRecord {
        return
            try KeysendTlvRecord(
                type: FfiConverterUInt64.read(from: &buf), 
                value: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: KeysendTlvRecord, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.type, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
    }
}


public func FfiConverterTypeKeysendTLVRecord_lift(_ buf: RustBuffer) throws -> KeysendTlvRecord {
    return try FfiConverterTypeKeysendTLVRecord.lift(buf)
}

public func FfiConverterTypeKeysendTLVRecord_lower(_ value: KeysendTlvRecord) -> RustBuffer {
    return FfiConverterTypeKeysendTLVRecord.lower(value)
}


/**
 * These are limitations imposed by the relay on clients. Your client should
 * expect that requests which exceed these practical limitations are rejected or fail immediately.
 */
public struct Limitation {
    /**
     * Maximum number of bytes for incoming JSON that the relay will attempt to decode and act upon
     */
    public var maxMessageLength: Int32?
    /**
     * Total number of subscriptions that may be active on a single websocket connection
     */
    public var maxSubscriptions: Int32?
    /**
     * Maximum number of filter values in each subscription
     */
    public var maxFilters: Int32?
    /**
     * Relay will clamp each filter's limit value to this number
     */
    public var maxLimit: Int32?
    /**
     * Maximum length of subscription id as a string
     */
    public var maxSubidLength: Int32?
    /**
     * Maximum number of elements in the tags list
     */
    public var maxEventTags: Int32?
    /**
     * Maximum number of characters in the content field of any event
     */
    public var maxContentLength: Int32?
    /**
     * New events will require at least this difficulty of PoW,
     */
    public var minPowDifficulty: Int32?
    /**
     * Relay requires NIP-42 authentication to happen before a new connection may perform any other action
     */
    public var authRequired: Bool?
    /**
     * Relay requires payment before a new connection may perform any action
     */
    public var paymentRequired: Bool?
    /**
     * 'created_at' lower limit
     */
    public var createdAtLowerLimit: Timestamp?
    /**
     * 'created_at' upper limit
     */
    public var createdAtUpperLimit: Timestamp?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Maximum number of bytes for incoming JSON that the relay will attempt to decode and act upon
         */
        maxMessageLength: Int32?, 
        /**
         * Total number of subscriptions that may be active on a single websocket connection
         */
        maxSubscriptions: Int32?, 
        /**
         * Maximum number of filter values in each subscription
         */
        maxFilters: Int32?, 
        /**
         * Relay will clamp each filter's limit value to this number
         */
        maxLimit: Int32?, 
        /**
         * Maximum length of subscription id as a string
         */
        maxSubidLength: Int32?, 
        /**
         * Maximum number of elements in the tags list
         */
        maxEventTags: Int32?, 
        /**
         * Maximum number of characters in the content field of any event
         */
        maxContentLength: Int32?, 
        /**
         * New events will require at least this difficulty of PoW,
         */
        minPowDifficulty: Int32?, 
        /**
         * Relay requires NIP-42 authentication to happen before a new connection may perform any other action
         */
        authRequired: Bool?, 
        /**
         * Relay requires payment before a new connection may perform any action
         */
        paymentRequired: Bool?, 
        /**
         * 'created_at' lower limit
         */
        createdAtLowerLimit: Timestamp?, 
        /**
         * 'created_at' upper limit
         */
        createdAtUpperLimit: Timestamp?) {
        self.maxMessageLength = maxMessageLength
        self.maxSubscriptions = maxSubscriptions
        self.maxFilters = maxFilters
        self.maxLimit = maxLimit
        self.maxSubidLength = maxSubidLength
        self.maxEventTags = maxEventTags
        self.maxContentLength = maxContentLength
        self.minPowDifficulty = minPowDifficulty
        self.authRequired = authRequired
        self.paymentRequired = paymentRequired
        self.createdAtLowerLimit = createdAtLowerLimit
        self.createdAtUpperLimit = createdAtUpperLimit
    }
}



public struct FfiConverterTypeLimitation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Limitation {
        return
            try Limitation(
                maxMessageLength: FfiConverterOptionInt32.read(from: &buf), 
                maxSubscriptions: FfiConverterOptionInt32.read(from: &buf), 
                maxFilters: FfiConverterOptionInt32.read(from: &buf), 
                maxLimit: FfiConverterOptionInt32.read(from: &buf), 
                maxSubidLength: FfiConverterOptionInt32.read(from: &buf), 
                maxEventTags: FfiConverterOptionInt32.read(from: &buf), 
                maxContentLength: FfiConverterOptionInt32.read(from: &buf), 
                minPowDifficulty: FfiConverterOptionInt32.read(from: &buf), 
                authRequired: FfiConverterOptionBool.read(from: &buf), 
                paymentRequired: FfiConverterOptionBool.read(from: &buf), 
                createdAtLowerLimit: FfiConverterOptionTypeTimestamp.read(from: &buf), 
                createdAtUpperLimit: FfiConverterOptionTypeTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: Limitation, into buf: inout [UInt8]) {
        FfiConverterOptionInt32.write(value.maxMessageLength, into: &buf)
        FfiConverterOptionInt32.write(value.maxSubscriptions, into: &buf)
        FfiConverterOptionInt32.write(value.maxFilters, into: &buf)
        FfiConverterOptionInt32.write(value.maxLimit, into: &buf)
        FfiConverterOptionInt32.write(value.maxSubidLength, into: &buf)
        FfiConverterOptionInt32.write(value.maxEventTags, into: &buf)
        FfiConverterOptionInt32.write(value.maxContentLength, into: &buf)
        FfiConverterOptionInt32.write(value.minPowDifficulty, into: &buf)
        FfiConverterOptionBool.write(value.authRequired, into: &buf)
        FfiConverterOptionBool.write(value.paymentRequired, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.createdAtLowerLimit, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.createdAtUpperLimit, into: &buf)
    }
}


public func FfiConverterTypeLimitation_lift(_ buf: RustBuffer) throws -> Limitation {
    return try FfiConverterTypeLimitation.lift(buf)
}

public func FfiConverterTypeLimitation_lower(_ value: Limitation) -> RustBuffer {
    return FfiConverterTypeLimitation.lower(value)
}


/**
 * List Invoice Request Params
 */
public struct ListInvoicesRequestParams {
    /**
     * Starting timestamp in seconds since epoch
     */
    public var from: UInt64?
    /**
     * Ending timestamp in seconds since epoch
     */
    public var until: UInt64?
    /**
     * Number of invoices to return
     */
    public var limit: UInt64?
    /**
     * Offset of the first invoice to return
     */
    public var offset: UInt64?
    /**
     * If true, include unpaid invoices
     */
    public var unpaid: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Starting timestamp in seconds since epoch
         */
        from: UInt64?, 
        /**
         * Ending timestamp in seconds since epoch
         */
        until: UInt64?, 
        /**
         * Number of invoices to return
         */
        limit: UInt64?, 
        /**
         * Offset of the first invoice to return
         */
        offset: UInt64?, 
        /**
         * If true, include unpaid invoices
         */
        unpaid: Bool?) {
        self.from = from
        self.until = until
        self.limit = limit
        self.offset = offset
        self.unpaid = unpaid
    }
}


extension ListInvoicesRequestParams: Equatable, Hashable {
    public static func ==(lhs: ListInvoicesRequestParams, rhs: ListInvoicesRequestParams) -> Bool {
        if lhs.from != rhs.from {
            return false
        }
        if lhs.until != rhs.until {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        if lhs.offset != rhs.offset {
            return false
        }
        if lhs.unpaid != rhs.unpaid {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(from)
        hasher.combine(until)
        hasher.combine(limit)
        hasher.combine(offset)
        hasher.combine(unpaid)
    }
}


public struct FfiConverterTypeListInvoicesRequestParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListInvoicesRequestParams {
        return
            try ListInvoicesRequestParams(
                from: FfiConverterOptionUInt64.read(from: &buf), 
                until: FfiConverterOptionUInt64.read(from: &buf), 
                limit: FfiConverterOptionUInt64.read(from: &buf), 
                offset: FfiConverterOptionUInt64.read(from: &buf), 
                unpaid: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: ListInvoicesRequestParams, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.from, into: &buf)
        FfiConverterOptionUInt64.write(value.until, into: &buf)
        FfiConverterOptionUInt64.write(value.limit, into: &buf)
        FfiConverterOptionUInt64.write(value.offset, into: &buf)
        FfiConverterOptionBool.write(value.unpaid, into: &buf)
    }
}


public func FfiConverterTypeListInvoicesRequestParams_lift(_ buf: RustBuffer) throws -> ListInvoicesRequestParams {
    return try FfiConverterTypeListInvoicesRequestParams.lift(buf)
}

public func FfiConverterTypeListInvoicesRequestParams_lower(_ value: ListInvoicesRequestParams) -> RustBuffer {
    return FfiConverterTypeListInvoicesRequestParams.lower(value)
}


/**
 * NIP47 Response Result
 */
public struct ListPaymentResponseResult {
    /**
     * Bolt11 invoice
     */
    public var invoice: String
    /**
     * Preimage for the payment
     */
    public var preimage: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Bolt11 invoice
         */
        invoice: String, 
        /**
         * Preimage for the payment
         */
        preimage: String?) {
        self.invoice = invoice
        self.preimage = preimage
    }
}


extension ListPaymentResponseResult: Equatable, Hashable {
    public static func ==(lhs: ListPaymentResponseResult, rhs: ListPaymentResponseResult) -> Bool {
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.preimage != rhs.preimage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(invoice)
        hasher.combine(preimage)
    }
}


public struct FfiConverterTypeListPaymentResponseResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListPaymentResponseResult {
        return
            try ListPaymentResponseResult(
                invoice: FfiConverterString.read(from: &buf), 
                preimage: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ListPaymentResponseResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.invoice, into: &buf)
        FfiConverterOptionString.write(value.preimage, into: &buf)
    }
}


public func FfiConverterTypeListPaymentResponseResult_lift(_ buf: RustBuffer) throws -> ListPaymentResponseResult {
    return try FfiConverterTypeListPaymentResponseResult.lift(buf)
}

public func FfiConverterTypeListPaymentResponseResult_lower(_ value: ListPaymentResponseResult) -> RustBuffer {
    return FfiConverterTypeListPaymentResponseResult.lower(value)
}


/**
 * List Payments Request Params
 */
public struct ListPaymentsRequestParams {
    /**
     * Starting timestamp in seconds since epoch
     */
    public var from: UInt64?
    /**
     * Ending timestamp in seconds since epoch
     */
    public var until: UInt64?
    /**
     * Number of invoices to return
     */
    public var limit: UInt64?
    /**
     * Offset of the first invoice to return
     */
    public var offset: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Starting timestamp in seconds since epoch
         */
        from: UInt64?, 
        /**
         * Ending timestamp in seconds since epoch
         */
        until: UInt64?, 
        /**
         * Number of invoices to return
         */
        limit: UInt64?, 
        /**
         * Offset of the first invoice to return
         */
        offset: UInt64?) {
        self.from = from
        self.until = until
        self.limit = limit
        self.offset = offset
    }
}


extension ListPaymentsRequestParams: Equatable, Hashable {
    public static func ==(lhs: ListPaymentsRequestParams, rhs: ListPaymentsRequestParams) -> Bool {
        if lhs.from != rhs.from {
            return false
        }
        if lhs.until != rhs.until {
            return false
        }
        if lhs.limit != rhs.limit {
            return false
        }
        if lhs.offset != rhs.offset {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(from)
        hasher.combine(until)
        hasher.combine(limit)
        hasher.combine(offset)
    }
}


public struct FfiConverterTypeListPaymentsRequestParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListPaymentsRequestParams {
        return
            try ListPaymentsRequestParams(
                from: FfiConverterOptionUInt64.read(from: &buf), 
                until: FfiConverterOptionUInt64.read(from: &buf), 
                limit: FfiConverterOptionUInt64.read(from: &buf), 
                offset: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ListPaymentsRequestParams, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.from, into: &buf)
        FfiConverterOptionUInt64.write(value.until, into: &buf)
        FfiConverterOptionUInt64.write(value.limit, into: &buf)
        FfiConverterOptionUInt64.write(value.offset, into: &buf)
    }
}


public func FfiConverterTypeListPaymentsRequestParams_lift(_ buf: RustBuffer) throws -> ListPaymentsRequestParams {
    return try FfiConverterTypeListPaymentsRequestParams.lift(buf)
}

public func FfiConverterTypeListPaymentsRequestParams_lower(_ value: ListPaymentsRequestParams) -> RustBuffer {
    return FfiConverterTypeListPaymentsRequestParams.lower(value)
}


public struct LiveEvent {
    public var id: String
    public var title: String?
    public var summary: String?
    public var image: Image?
    public var hashtags: [String]
    public var streaming: String?
    public var recording: String?
    public var start: Timestamp?
    public var ends: Timestamp?
    public var status: LiveEventStatus?
    public var currentParticipants: UInt64?
    public var totalParticipants: UInt64?
    public var relays: [String]
    public var host: LiveEventHost?
    public var speakers: [Person]
    public var participants: [Person]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        id: String, 
        title: String?, 
        summary: String?, 
        image: Image?, 
        hashtags: [String], 
        streaming: String?, 
        recording: String?, 
        start: Timestamp?, 
        ends: Timestamp?, 
        status: LiveEventStatus?, 
        currentParticipants: UInt64?, 
        totalParticipants: UInt64?, 
        relays: [String], 
        host: LiveEventHost?, 
        speakers: [Person], 
        participants: [Person]) {
        self.id = id
        self.title = title
        self.summary = summary
        self.image = image
        self.hashtags = hashtags
        self.streaming = streaming
        self.recording = recording
        self.start = start
        self.ends = ends
        self.status = status
        self.currentParticipants = currentParticipants
        self.totalParticipants = totalParticipants
        self.relays = relays
        self.host = host
        self.speakers = speakers
        self.participants = participants
    }
}



public struct FfiConverterTypeLiveEvent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveEvent {
        return
            try LiveEvent(
                id: FfiConverterString.read(from: &buf), 
                title: FfiConverterOptionString.read(from: &buf), 
                summary: FfiConverterOptionString.read(from: &buf), 
                image: FfiConverterOptionTypeImage.read(from: &buf), 
                hashtags: FfiConverterSequenceString.read(from: &buf), 
                streaming: FfiConverterOptionString.read(from: &buf), 
                recording: FfiConverterOptionString.read(from: &buf), 
                start: FfiConverterOptionTypeTimestamp.read(from: &buf), 
                ends: FfiConverterOptionTypeTimestamp.read(from: &buf), 
                status: FfiConverterOptionTypeLiveEventStatus.read(from: &buf), 
                currentParticipants: FfiConverterOptionUInt64.read(from: &buf), 
                totalParticipants: FfiConverterOptionUInt64.read(from: &buf), 
                relays: FfiConverterSequenceString.read(from: &buf), 
                host: FfiConverterOptionTypeLiveEventHost.read(from: &buf), 
                speakers: FfiConverterSequenceTypePerson.read(from: &buf), 
                participants: FfiConverterSequenceTypePerson.read(from: &buf)
        )
    }

    public static func write(_ value: LiveEvent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.title, into: &buf)
        FfiConverterOptionString.write(value.summary, into: &buf)
        FfiConverterOptionTypeImage.write(value.image, into: &buf)
        FfiConverterSequenceString.write(value.hashtags, into: &buf)
        FfiConverterOptionString.write(value.streaming, into: &buf)
        FfiConverterOptionString.write(value.recording, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.start, into: &buf)
        FfiConverterOptionTypeTimestamp.write(value.ends, into: &buf)
        FfiConverterOptionTypeLiveEventStatus.write(value.status, into: &buf)
        FfiConverterOptionUInt64.write(value.currentParticipants, into: &buf)
        FfiConverterOptionUInt64.write(value.totalParticipants, into: &buf)
        FfiConverterSequenceString.write(value.relays, into: &buf)
        FfiConverterOptionTypeLiveEventHost.write(value.host, into: &buf)
        FfiConverterSequenceTypePerson.write(value.speakers, into: &buf)
        FfiConverterSequenceTypePerson.write(value.participants, into: &buf)
    }
}


public func FfiConverterTypeLiveEvent_lift(_ buf: RustBuffer) throws -> LiveEvent {
    return try FfiConverterTypeLiveEvent.lift(buf)
}

public func FfiConverterTypeLiveEvent_lower(_ value: LiveEvent) -> RustBuffer {
    return FfiConverterTypeLiveEvent.lower(value)
}


public struct LiveEventHost {
    public var publicKey: PublicKey
    public var relayUrl: String?
    public var proof: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        publicKey: PublicKey, 
        relayUrl: String?, 
        proof: String?) {
        self.publicKey = publicKey
        self.relayUrl = relayUrl
        self.proof = proof
    }
}



public struct FfiConverterTypeLiveEventHost: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveEventHost {
        return
            try LiveEventHost(
                publicKey: FfiConverterTypePublicKey.read(from: &buf), 
                relayUrl: FfiConverterOptionString.read(from: &buf), 
                proof: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LiveEventHost, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.publicKey, into: &buf)
        FfiConverterOptionString.write(value.relayUrl, into: &buf)
        FfiConverterOptionString.write(value.proof, into: &buf)
    }
}


public func FfiConverterTypeLiveEventHost_lift(_ buf: RustBuffer) throws -> LiveEventHost {
    return try FfiConverterTypeLiveEventHost.lift(buf)
}

public func FfiConverterTypeLiveEventHost_lower(_ value: LiveEventHost) -> RustBuffer {
    return FfiConverterTypeLiveEventHost.lower(value)
}


/**
 * Lookup Invoice Request Params
 */
public struct LookupInvoiceRequestParams {
    /**
     * Payment hash of invoice
     */
    public var paymentHash: String?
    /**
     * Bolt11 invoice
     */
    public var bolt11: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Payment hash of invoice
         */
        paymentHash: String?, 
        /**
         * Bolt11 invoice
         */
        bolt11: String?) {
        self.paymentHash = paymentHash
        self.bolt11 = bolt11
    }
}


extension LookupInvoiceRequestParams: Equatable, Hashable {
    public static func ==(lhs: LookupInvoiceRequestParams, rhs: LookupInvoiceRequestParams) -> Bool {
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        if lhs.bolt11 != rhs.bolt11 {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(paymentHash)
        hasher.combine(bolt11)
    }
}


public struct FfiConverterTypeLookupInvoiceRequestParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LookupInvoiceRequestParams {
        return
            try LookupInvoiceRequestParams(
                paymentHash: FfiConverterOptionString.read(from: &buf), 
                bolt11: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LookupInvoiceRequestParams, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.paymentHash, into: &buf)
        FfiConverterOptionString.write(value.bolt11, into: &buf)
    }
}


public func FfiConverterTypeLookupInvoiceRequestParams_lift(_ buf: RustBuffer) throws -> LookupInvoiceRequestParams {
    return try FfiConverterTypeLookupInvoiceRequestParams.lift(buf)
}

public func FfiConverterTypeLookupInvoiceRequestParams_lower(_ value: LookupInvoiceRequestParams) -> RustBuffer {
    return FfiConverterTypeLookupInvoiceRequestParams.lower(value)
}


/**
 * NIP47 Response Result
 */
public struct LookupInvoiceResponseResult {
    /**
     * Bolt11 invoice
     */
    public var invoice: String
    /**
     * If the invoice has been paid
     */
    public var paid: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Bolt11 invoice
         */
        invoice: String, 
        /**
         * If the invoice has been paid
         */
        paid: Bool) {
        self.invoice = invoice
        self.paid = paid
    }
}


extension LookupInvoiceResponseResult: Equatable, Hashable {
    public static func ==(lhs: LookupInvoiceResponseResult, rhs: LookupInvoiceResponseResult) -> Bool {
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.paid != rhs.paid {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(invoice)
        hasher.combine(paid)
    }
}


public struct FfiConverterTypeLookupInvoiceResponseResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LookupInvoiceResponseResult {
        return
            try LookupInvoiceResponseResult(
                invoice: FfiConverterString.read(from: &buf), 
                paid: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: LookupInvoiceResponseResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.invoice, into: &buf)
        FfiConverterBool.write(value.paid, into: &buf)
    }
}


public func FfiConverterTypeLookupInvoiceResponseResult_lift(_ buf: RustBuffer) throws -> LookupInvoiceResponseResult {
    return try FfiConverterTypeLookupInvoiceResponseResult.lift(buf)
}

public func FfiConverterTypeLookupInvoiceResponseResult_lower(_ value: LookupInvoiceResponseResult) -> RustBuffer {
    return FfiConverterTypeLookupInvoiceResponseResult.lower(value)
}


/**
 * Make Invoice Request Params
 */
public struct MakeInvoiceRequestParams {
    /**
     * Amount in millisatoshis
     */
    public var amount: Int64
    /**
     * Invoice description
     */
    public var description: String?
    /**
     * Invoice description hash
     */
    public var descriptionHash: String?
    /**
     * Preimage to be used for the invoice
     */
    public var preimage: String?
    /**
     * Invoice expiry in seconds
     */
    public var expiry: Int64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Amount in millisatoshis
         */
        amount: Int64, 
        /**
         * Invoice description
         */
        description: String?, 
        /**
         * Invoice description hash
         */
        descriptionHash: String?, 
        /**
         * Preimage to be used for the invoice
         */
        preimage: String?, 
        /**
         * Invoice expiry in seconds
         */
        expiry: Int64?) {
        self.amount = amount
        self.description = description
        self.descriptionHash = descriptionHash
        self.preimage = preimage
        self.expiry = expiry
    }
}


extension MakeInvoiceRequestParams: Equatable, Hashable {
    public static func ==(lhs: MakeInvoiceRequestParams, rhs: MakeInvoiceRequestParams) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.descriptionHash != rhs.descriptionHash {
            return false
        }
        if lhs.preimage != rhs.preimage {
            return false
        }
        if lhs.expiry != rhs.expiry {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
        hasher.combine(description)
        hasher.combine(descriptionHash)
        hasher.combine(preimage)
        hasher.combine(expiry)
    }
}


public struct FfiConverterTypeMakeInvoiceRequestParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MakeInvoiceRequestParams {
        return
            try MakeInvoiceRequestParams(
                amount: FfiConverterInt64.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                descriptionHash: FfiConverterOptionString.read(from: &buf), 
                preimage: FfiConverterOptionString.read(from: &buf), 
                expiry: FfiConverterOptionInt64.read(from: &buf)
        )
    }

    public static func write(_ value: MakeInvoiceRequestParams, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.amount, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionString.write(value.descriptionHash, into: &buf)
        FfiConverterOptionString.write(value.preimage, into: &buf)
        FfiConverterOptionInt64.write(value.expiry, into: &buf)
    }
}


public func FfiConverterTypeMakeInvoiceRequestParams_lift(_ buf: RustBuffer) throws -> MakeInvoiceRequestParams {
    return try FfiConverterTypeMakeInvoiceRequestParams.lift(buf)
}

public func FfiConverterTypeMakeInvoiceRequestParams_lower(_ value: MakeInvoiceRequestParams) -> RustBuffer {
    return FfiConverterTypeMakeInvoiceRequestParams.lower(value)
}


/**
 * NIP47 Response Result
 */
public struct MakeInvoiceResponseResult {
    /**
     * Bolt 11 invoice
     */
    public var invoice: String
    /**
     * Invoice's payment hash
     */
    public var paymentHash: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Bolt 11 invoice
         */
        invoice: String, 
        /**
         * Invoice's payment hash
         */
        paymentHash: String) {
        self.invoice = invoice
        self.paymentHash = paymentHash
    }
}


extension MakeInvoiceResponseResult: Equatable, Hashable {
    public static func ==(lhs: MakeInvoiceResponseResult, rhs: MakeInvoiceResponseResult) -> Bool {
        if lhs.invoice != rhs.invoice {
            return false
        }
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(invoice)
        hasher.combine(paymentHash)
    }
}


public struct FfiConverterTypeMakeInvoiceResponseResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MakeInvoiceResponseResult {
        return
            try MakeInvoiceResponseResult(
                invoice: FfiConverterString.read(from: &buf), 
                paymentHash: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: MakeInvoiceResponseResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.invoice, into: &buf)
        FfiConverterString.write(value.paymentHash, into: &buf)
    }
}


public func FfiConverterTypeMakeInvoiceResponseResult_lift(_ buf: RustBuffer) throws -> MakeInvoiceResponseResult {
    return try FfiConverterTypeMakeInvoiceResponseResult.lift(buf)
}

public func FfiConverterTypeMakeInvoiceResponseResult_lower(_ value: MakeInvoiceResponseResult) -> RustBuffer {
    return FfiConverterTypeMakeInvoiceResponseResult.lower(value)
}


/**
 * NIP47 Error message
 */
public struct Nip47Error {
    /**
     * Error Code
     */
    public var code: ErrorCode
    /**
     * Human Readable error message
     */
    public var message: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Error Code
         */
        code: ErrorCode, 
        /**
         * Human Readable error message
         */
        message: String) {
        self.code = code
        self.message = message
    }
}


extension Nip47Error: Equatable, Hashable {
    public static func ==(lhs: Nip47Error, rhs: Nip47Error) -> Bool {
        if lhs.code != rhs.code {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(code)
        hasher.combine(message)
    }
}


public struct FfiConverterTypeNIP47Error: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip47Error {
        return
            try Nip47Error(
                code: FfiConverterTypeErrorCode.read(from: &buf), 
                message: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Nip47Error, into buf: inout [UInt8]) {
        FfiConverterTypeErrorCode.write(value.code, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
    }
}


public func FfiConverterTypeNIP47Error_lift(_ buf: RustBuffer) throws -> Nip47Error {
    return try FfiConverterTypeNIP47Error.lift(buf)
}

public func FfiConverterTypeNIP47Error_lower(_ value: Nip47Error) -> RustBuffer {
    return FfiConverterTypeNIP47Error.lower(value)
}


/**
 * Pay Invoice Request Params
 */
public struct PayInvoiceRequestParams {
    /**
     * Request invoice
     */
    public var invoice: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Request invoice
         */
        invoice: String) {
        self.invoice = invoice
    }
}


extension PayInvoiceRequestParams: Equatable, Hashable {
    public static func ==(lhs: PayInvoiceRequestParams, rhs: PayInvoiceRequestParams) -> Bool {
        if lhs.invoice != rhs.invoice {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(invoice)
    }
}


public struct FfiConverterTypePayInvoiceRequestParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayInvoiceRequestParams {
        return
            try PayInvoiceRequestParams(
                invoice: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PayInvoiceRequestParams, into buf: inout [UInt8]) {
        FfiConverterString.write(value.invoice, into: &buf)
    }
}


public func FfiConverterTypePayInvoiceRequestParams_lift(_ buf: RustBuffer) throws -> PayInvoiceRequestParams {
    return try FfiConverterTypePayInvoiceRequestParams.lift(buf)
}

public func FfiConverterTypePayInvoiceRequestParams_lower(_ value: PayInvoiceRequestParams) -> RustBuffer {
    return FfiConverterTypePayInvoiceRequestParams.lower(value)
}


/**
 * NIP47 Response Result
 */
public struct PayInvoiceResponseResult {
    /**
     * Response preimage
     */
    public var preimage: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Response preimage
         */
        preimage: String) {
        self.preimage = preimage
    }
}


extension PayInvoiceResponseResult: Equatable, Hashable {
    public static func ==(lhs: PayInvoiceResponseResult, rhs: PayInvoiceResponseResult) -> Bool {
        if lhs.preimage != rhs.preimage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(preimage)
    }
}


public struct FfiConverterTypePayInvoiceResponseResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayInvoiceResponseResult {
        return
            try PayInvoiceResponseResult(
                preimage: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PayInvoiceResponseResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.preimage, into: &buf)
    }
}


public func FfiConverterTypePayInvoiceResponseResult_lift(_ buf: RustBuffer) throws -> PayInvoiceResponseResult {
    return try FfiConverterTypePayInvoiceResponseResult.lift(buf)
}

public func FfiConverterTypePayInvoiceResponseResult_lower(_ value: PayInvoiceResponseResult) -> RustBuffer {
    return FfiConverterTypePayInvoiceResponseResult.lower(value)
}


/**
 * Pay Invoice Request Params
 */
public struct PayKeysendRequestParams {
    /**
     * Amount in millisatoshis
     */
    public var amount: Int64
    /**
     * Receiver's node id
     */
    public var pubkey: String
    /**
     * Optional message
     */
    public var message: String?
    /**
     * Optional preimage
     */
    public var preimage: String?
    /**
     * Optional TLVs to be added to the keysend payment
     */
    public var tlvRecords: [KeysendTlvRecord]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Amount in millisatoshis
         */
        amount: Int64, 
        /**
         * Receiver's node id
         */
        pubkey: String, 
        /**
         * Optional message
         */
        message: String?, 
        /**
         * Optional preimage
         */
        preimage: String?, 
        /**
         * Optional TLVs to be added to the keysend payment
         */
        tlvRecords: [KeysendTlvRecord]) {
        self.amount = amount
        self.pubkey = pubkey
        self.message = message
        self.preimage = preimage
        self.tlvRecords = tlvRecords
    }
}


extension PayKeysendRequestParams: Equatable, Hashable {
    public static func ==(lhs: PayKeysendRequestParams, rhs: PayKeysendRequestParams) -> Bool {
        if lhs.amount != rhs.amount {
            return false
        }
        if lhs.pubkey != rhs.pubkey {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.preimage != rhs.preimage {
            return false
        }
        if lhs.tlvRecords != rhs.tlvRecords {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount)
        hasher.combine(pubkey)
        hasher.combine(message)
        hasher.combine(preimage)
        hasher.combine(tlvRecords)
    }
}


public struct FfiConverterTypePayKeysendRequestParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayKeysendRequestParams {
        return
            try PayKeysendRequestParams(
                amount: FfiConverterInt64.read(from: &buf), 
                pubkey: FfiConverterString.read(from: &buf), 
                message: FfiConverterOptionString.read(from: &buf), 
                preimage: FfiConverterOptionString.read(from: &buf), 
                tlvRecords: FfiConverterSequenceTypeKeysendTLVRecord.read(from: &buf)
        )
    }

    public static func write(_ value: PayKeysendRequestParams, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.amount, into: &buf)
        FfiConverterString.write(value.pubkey, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
        FfiConverterOptionString.write(value.preimage, into: &buf)
        FfiConverterSequenceTypeKeysendTLVRecord.write(value.tlvRecords, into: &buf)
    }
}


public func FfiConverterTypePayKeysendRequestParams_lift(_ buf: RustBuffer) throws -> PayKeysendRequestParams {
    return try FfiConverterTypePayKeysendRequestParams.lift(buf)
}

public func FfiConverterTypePayKeysendRequestParams_lower(_ value: PayKeysendRequestParams) -> RustBuffer {
    return FfiConverterTypePayKeysendRequestParams.lower(value)
}


/**
 * NIP47 Response Result
 */
public struct PayKeysendResponseResult {
    /**
     * Response preimage
     */
    public var preimage: String
    /**
     * Payment hash
     */
    public var paymentHash: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Response preimage
         */
        preimage: String, 
        /**
         * Payment hash
         */
        paymentHash: String) {
        self.preimage = preimage
        self.paymentHash = paymentHash
    }
}


extension PayKeysendResponseResult: Equatable, Hashable {
    public static func ==(lhs: PayKeysendResponseResult, rhs: PayKeysendResponseResult) -> Bool {
        if lhs.preimage != rhs.preimage {
            return false
        }
        if lhs.paymentHash != rhs.paymentHash {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(preimage)
        hasher.combine(paymentHash)
    }
}


public struct FfiConverterTypePayKeysendResponseResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PayKeysendResponseResult {
        return
            try PayKeysendResponseResult(
                preimage: FfiConverterString.read(from: &buf), 
                paymentHash: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PayKeysendResponseResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.preimage, into: &buf)
        FfiConverterString.write(value.paymentHash, into: &buf)
    }
}


public func FfiConverterTypePayKeysendResponseResult_lift(_ buf: RustBuffer) throws -> PayKeysendResponseResult {
    return try FfiConverterTypePayKeysendResponseResult.lift(buf)
}

public func FfiConverterTypePayKeysendResponseResult_lower(_ value: PayKeysendResponseResult) -> RustBuffer {
    return FfiConverterTypePayKeysendResponseResult.lower(value)
}


public struct Person {
    public var publicKey: PublicKey
    public var url: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        publicKey: PublicKey, 
        url: String?) {
        self.publicKey = publicKey
        self.url = url
    }
}



public struct FfiConverterTypePerson: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Person {
        return
            try Person(
                publicKey: FfiConverterTypePublicKey.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: Person, into buf: inout [UInt8]) {
        FfiConverterTypePublicKey.write(value.publicKey, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
    }
}


public func FfiConverterTypePerson_lift(_ buf: RustBuffer) throws -> Person {
    return try FfiConverterTypePerson.lift(buf)
}

public func FfiConverterTypePerson_lower(_ value: Person) -> RustBuffer {
    return FfiConverterTypePerson.lower(value)
}


/**
 * Payload for creating or updating product
 */
public struct ProductData {
    /**
     * UUID of the product generated by merchant
     */
    public var id: String
    /**
     * Id of the stall that this product belongs to
     */
    public var stallId: String
    /**
     * Product name
     */
    public var name: String
    /**
     * Description of the product
     */
    public var description: String?
    /**
     * Image urls of the product
     */
    public var images: [String]?
    /**
     * Currency used
     */
    public var currency: String
    /**
     * Price of the product
     */
    public var price: Double
    /**
     * Available items
     */
    public var quantity: UInt64
    /**
     * Specifications of the product
     */
    public var specs: [[String]]?
    /**
     * Shipping method costs
     */
    public var shipping: [ShippingCost]
    /**
     * Categories of the product (will be added to tags)
     */
    public var categories: [String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * UUID of the product generated by merchant
         */
        id: String, 
        /**
         * Id of the stall that this product belongs to
         */
        stallId: String, 
        /**
         * Product name
         */
        name: String, 
        /**
         * Description of the product
         */
        description: String?, 
        /**
         * Image urls of the product
         */
        images: [String]?, 
        /**
         * Currency used
         */
        currency: String, 
        /**
         * Price of the product
         */
        price: Double, 
        /**
         * Available items
         */
        quantity: UInt64, 
        /**
         * Specifications of the product
         */
        specs: [[String]]?, 
        /**
         * Shipping method costs
         */
        shipping: [ShippingCost], 
        /**
         * Categories of the product (will be added to tags)
         */
        categories: [String]?) {
        self.id = id
        self.stallId = stallId
        self.name = name
        self.description = description
        self.images = images
        self.currency = currency
        self.price = price
        self.quantity = quantity
        self.specs = specs
        self.shipping = shipping
        self.categories = categories
    }
}


extension ProductData: Equatable, Hashable {
    public static func ==(lhs: ProductData, rhs: ProductData) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.stallId != rhs.stallId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.description != rhs.description {
            return false
        }
        if lhs.images != rhs.images {
            return false
        }
        if lhs.currency != rhs.currency {
            return false
        }
        if lhs.price != rhs.price {
            return false
        }
        if lhs.quantity != rhs.quantity {
            return false
        }
        if lhs.specs != rhs.specs {
            return false
        }
        if lhs.shipping != rhs.shipping {
            return false
        }
        if lhs.categories != rhs.categories {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(stallId)
        hasher.combine(name)
        hasher.combine(description)
        hasher.combine(images)
        hasher.combine(currency)
        hasher.combine(price)
        hasher.combine(quantity)
        hasher.combine(specs)
        hasher.combine(shipping)
        hasher.combine(categories)
    }
}


public struct FfiConverterTypeProductData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProductData {
        return
            try ProductData(
                id: FfiConverterString.read(from: &buf), 
                stallId: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                images: FfiConverterOptionSequenceString.read(from: &buf), 
                currency: FfiConverterString.read(from: &buf), 
                price: FfiConverterDouble.read(from: &buf), 
                quantity: FfiConverterUInt64.read(from: &buf), 
                specs: FfiConverterOptionSequenceSequenceString.read(from: &buf), 
                shipping: FfiConverterSequenceTypeShippingCost.read(from: &buf), 
                categories: FfiConverterOptionSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: ProductData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.stallId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionSequenceString.write(value.images, into: &buf)
        FfiConverterString.write(value.currency, into: &buf)
        FfiConverterDouble.write(value.price, into: &buf)
        FfiConverterUInt64.write(value.quantity, into: &buf)
        FfiConverterOptionSequenceSequenceString.write(value.specs, into: &buf)
        FfiConverterSequenceTypeShippingCost.write(value.shipping, into: &buf)
        FfiConverterOptionSequenceString.write(value.categories, into: &buf)
    }
}


public func FfiConverterTypeProductData_lift(_ buf: RustBuffer) throws -> ProductData {
    return try FfiConverterTypeProductData.lift(buf)
}

public func FfiConverterTypeProductData_lower(_ value: ProductData) -> RustBuffer {
    return FfiConverterTypeProductData.lower(value)
}


/**
 * A retention shedule for the relay
 */
public struct Retention {
    /**
     * The event kinds this retention pertains to
     */
    public var kinds: [RetentionKind]?
    /**
     * The amount of time these events are kept
     */
    public var time: UInt64?
    /**
     * The max number of events kept before removing older events
     */
    public var count: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The event kinds this retention pertains to
         */
        kinds: [RetentionKind]?, 
        /**
         * The amount of time these events are kept
         */
        time: UInt64?, 
        /**
         * The max number of events kept before removing older events
         */
        count: UInt64?) {
        self.kinds = kinds
        self.time = time
        self.count = count
    }
}


extension Retention: Equatable, Hashable {
    public static func ==(lhs: Retention, rhs: Retention) -> Bool {
        if lhs.kinds != rhs.kinds {
            return false
        }
        if lhs.time != rhs.time {
            return false
        }
        if lhs.count != rhs.count {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(kinds)
        hasher.combine(time)
        hasher.combine(count)
    }
}


public struct FfiConverterTypeRetention: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Retention {
        return
            try Retention(
                kinds: FfiConverterOptionSequenceTypeRetentionKind.read(from: &buf), 
                time: FfiConverterOptionUInt64.read(from: &buf), 
                count: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Retention, into buf: inout [UInt8]) {
        FfiConverterOptionSequenceTypeRetentionKind.write(value.kinds, into: &buf)
        FfiConverterOptionUInt64.write(value.time, into: &buf)
        FfiConverterOptionUInt64.write(value.count, into: &buf)
    }
}


public func FfiConverterTypeRetention_lift(_ buf: RustBuffer) throws -> Retention {
    return try FfiConverterTypeRetention.lift(buf)
}

public func FfiConverterTypeRetention_lower(_ value: Retention) -> RustBuffer {
    return FfiConverterTypeRetention.lower(value)
}


/**
 * Delivery cost for shipping method as defined by the merchant in the product
 */
public struct ShippingCost {
    /**
     * Id of the shipping method
     */
    public var id: String
    /**
     * Cost to use this shipping method
     */
    public var cost: Double

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Id of the shipping method
         */
        id: String, 
        /**
         * Cost to use this shipping method
         */
        cost: Double) {
        self.id = id
        self.cost = cost
    }
}


extension ShippingCost: Equatable, Hashable {
    public static func ==(lhs: ShippingCost, rhs: ShippingCost) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.cost != rhs.cost {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(cost)
    }
}


public struct FfiConverterTypeShippingCost: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShippingCost {
        return
            try ShippingCost(
                id: FfiConverterString.read(from: &buf), 
                cost: FfiConverterDouble.read(from: &buf)
        )
    }

    public static func write(_ value: ShippingCost, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterDouble.write(value.cost, into: &buf)
    }
}


public func FfiConverterTypeShippingCost_lift(_ buf: RustBuffer) throws -> ShippingCost {
    return try FfiConverterTypeShippingCost.lift(buf)
}

public func FfiConverterTypeShippingCost_lower(_ value: ShippingCost) -> RustBuffer {
    return FfiConverterTypeShippingCost.lower(value)
}


/**
 * Payload for creating or updating stall
 */
public struct StallData {
    /**
     * UUID of the stall generated by merchant
     */
    public var id: String
    /**
     * Stall name
     */
    public var name: String
    /**
     * Stall description
     */
    public var description: String?
    /**
     * Currency used
     */
    public var currency: String
    /**
     * Available shipping methods
     */
    public var shipping: [ShippingMethod]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * UUID of the stall generated by merchant
         */
        id: String, 
        /**
         * Stall name
         */
        name: String, 
        /**
         * Stall description
         */
        description: String?, 
        /**
         * Currency used
         */
        currency: String, 
        /**
         * Available shipping methods
         */
        shipping: [ShippingMethod]) {
        self.id = id
        self.name = name
        self.description = description
        self.currency = currency
        self.shipping = shipping
    }
}



public struct FfiConverterTypeStallData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StallData {
        return
            try StallData(
                id: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                currency: FfiConverterString.read(from: &buf), 
                shipping: FfiConverterSequenceTypeShippingMethod.read(from: &buf)
        )
    }

    public static func write(_ value: StallData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterString.write(value.currency, into: &buf)
        FfiConverterSequenceTypeShippingMethod.write(value.shipping, into: &buf)
    }
}


public func FfiConverterTypeStallData_lift(_ buf: RustBuffer) throws -> StallData {
    return try FfiConverterTypeStallData.lift(buf)
}

public func FfiConverterTypeStallData_lower(_ value: StallData) -> RustBuffer {
    return FfiConverterTypeStallData.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum Alphabet {
    
    case a
    case b
    case c
    case d
    case e
    case f
    case g
    case h
    case i
    case j
    case k
    case l
    case m
    case n
    case o
    case p
    case q
    case r
    case s
    case t
    case u
    case v
    case w
    case x
    case y
    case z
}

public struct FfiConverterTypeAlphabet: FfiConverterRustBuffer {
    typealias SwiftType = Alphabet

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Alphabet {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .a
        
        case 2: return .b
        
        case 3: return .c
        
        case 4: return .d
        
        case 5: return .e
        
        case 6: return .f
        
        case 7: return .g
        
        case 8: return .h
        
        case 9: return .i
        
        case 10: return .j
        
        case 11: return .k
        
        case 12: return .l
        
        case 13: return .m
        
        case 14: return .n
        
        case 15: return .o
        
        case 16: return .p
        
        case 17: return .q
        
        case 18: return .r
        
        case 19: return .s
        
        case 20: return .t
        
        case 21: return .u
        
        case 22: return .v
        
        case 23: return .w
        
        case 24: return .x
        
        case 25: return .y
        
        case 26: return .z
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Alphabet, into buf: inout [UInt8]) {
        switch value {
        
        
        case .a:
            writeInt(&buf, Int32(1))
        
        
        case .b:
            writeInt(&buf, Int32(2))
        
        
        case .c:
            writeInt(&buf, Int32(3))
        
        
        case .d:
            writeInt(&buf, Int32(4))
        
        
        case .e:
            writeInt(&buf, Int32(5))
        
        
        case .f:
            writeInt(&buf, Int32(6))
        
        
        case .g:
            writeInt(&buf, Int32(7))
        
        
        case .h:
            writeInt(&buf, Int32(8))
        
        
        case .i:
            writeInt(&buf, Int32(9))
        
        
        case .j:
            writeInt(&buf, Int32(10))
        
        
        case .k:
            writeInt(&buf, Int32(11))
        
        
        case .l:
            writeInt(&buf, Int32(12))
        
        
        case .m:
            writeInt(&buf, Int32(13))
        
        
        case .n:
            writeInt(&buf, Int32(14))
        
        
        case .o:
            writeInt(&buf, Int32(15))
        
        
        case .p:
            writeInt(&buf, Int32(16))
        
        
        case .q:
            writeInt(&buf, Int32(17))
        
        
        case .r:
            writeInt(&buf, Int32(18))
        
        
        case .s:
            writeInt(&buf, Int32(19))
        
        
        case .t:
            writeInt(&buf, Int32(20))
        
        
        case .u:
            writeInt(&buf, Int32(21))
        
        
        case .v:
            writeInt(&buf, Int32(22))
        
        
        case .w:
            writeInt(&buf, Int32(23))
        
        
        case .x:
            writeInt(&buf, Int32(24))
        
        
        case .y:
            writeInt(&buf, Int32(25))
        
        
        case .z:
            writeInt(&buf, Int32(26))
        
        }
    }
}


public func FfiConverterTypeAlphabet_lift(_ buf: RustBuffer) throws -> Alphabet {
    return try FfiConverterTypeAlphabet.lift(buf)
}

public func FfiConverterTypeAlphabet_lower(_ value: Alphabet) -> RustBuffer {
    return FfiConverterTypeAlphabet.lower(value)
}


extension Alphabet: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Budget renewal type
 */
public enum BudgetType {
    
    /**
     * Daily
     */
    case daily
    /**
     * Weekly
     */
    case weekly
    /**
     * Monthly
     */
    case monthly
    /**
     * Yearly
     */
    case yearly
}

public struct FfiConverterTypeBudgetType: FfiConverterRustBuffer {
    typealias SwiftType = BudgetType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BudgetType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .daily
        
        case 2: return .weekly
        
        case 3: return .monthly
        
        case 4: return .yearly
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BudgetType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .daily:
            writeInt(&buf, Int32(1))
        
        
        case .weekly:
            writeInt(&buf, Int32(2))
        
        
        case .monthly:
            writeInt(&buf, Int32(3))
        
        
        case .yearly:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeBudgetType_lift(_ buf: RustBuffer) throws -> BudgetType {
    return try FfiConverterTypeBudgetType.lift(buf)
}

public func FfiConverterTypeBudgetType_lower(_ value: BudgetType) -> RustBuffer {
    return FfiConverterTypeBudgetType.lower(value)
}


extension BudgetType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Messages sent by clients, received by relays
 */
public enum ClientMessage {
    
    case eventMsg(
        event: Event
    )
    case req(
        subscriptionId: String, 
        filters: [Filter]
    )
    case count(
        subscriptionId: String, 
        filters: [Filter]
    )
    case close(
        subscriptionId: String
    )
    case auth(
        event: Event
    )
    /**
     * Negentropy Open
     */
    case negOpen(
        subscriptionId: String, 
        filter: Filter, 
        /**
         * ID size (MUST be between 8 and 32, inclusive)
         */
        idSize: UInt8, 
        initialMessage: String
    )
    /**
     * Negentropy Message
     */
    case negMsg(
        subscriptionId: String, 
        message: String
    )
    /**
     * Negentropy Close
     */
    case negClose(
        subscriptionId: String
    )
}

public struct FfiConverterTypeClientMessage: FfiConverterRustBuffer {
    typealias SwiftType = ClientMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .eventMsg(
            event: try FfiConverterTypeEvent.read(from: &buf)
        )
        
        case 2: return .req(
            subscriptionId: try FfiConverterString.read(from: &buf), 
            filters: try FfiConverterSequenceTypeFilter.read(from: &buf)
        )
        
        case 3: return .count(
            subscriptionId: try FfiConverterString.read(from: &buf), 
            filters: try FfiConverterSequenceTypeFilter.read(from: &buf)
        )
        
        case 4: return .close(
            subscriptionId: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .auth(
            event: try FfiConverterTypeEvent.read(from: &buf)
        )
        
        case 6: return .negOpen(
            subscriptionId: try FfiConverterString.read(from: &buf), 
            filter: try FfiConverterTypeFilter.read(from: &buf), 
            idSize: try FfiConverterUInt8.read(from: &buf), 
            initialMessage: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .negMsg(
            subscriptionId: try FfiConverterString.read(from: &buf), 
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .negClose(
            subscriptionId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .eventMsg(event):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEvent.write(event, into: &buf)
            
        
        case let .req(subscriptionId,filters):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterSequenceTypeFilter.write(filters, into: &buf)
            
        
        case let .count(subscriptionId,filters):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterSequenceTypeFilter.write(filters, into: &buf)
            
        
        case let .close(subscriptionId):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(subscriptionId, into: &buf)
            
        
        case let .auth(event):
            writeInt(&buf, Int32(5))
            FfiConverterTypeEvent.write(event, into: &buf)
            
        
        case let .negOpen(subscriptionId,filter,idSize,initialMessage):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterTypeFilter.write(filter, into: &buf)
            FfiConverterUInt8.write(idSize, into: &buf)
            FfiConverterString.write(initialMessage, into: &buf)
            
        
        case let .negMsg(subscriptionId,message):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        
        case let .negClose(subscriptionId):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(subscriptionId, into: &buf)
            
        }
    }
}


public func FfiConverterTypeClientMessage_lift(_ buf: RustBuffer) throws -> ClientMessage {
    return try FfiConverterTypeClientMessage.lift(buf)
}

public func FfiConverterTypeClientMessage_lower(_ value: ClientMessage) -> RustBuffer {
    return FfiConverterTypeClientMessage.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum DataVendingMachineStatus {
    
    case paymentRequired
    case processing
    case error
    case success
    case partial
}

public struct FfiConverterTypeDataVendingMachineStatus: FfiConverterRustBuffer {
    typealias SwiftType = DataVendingMachineStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DataVendingMachineStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .paymentRequired
        
        case 2: return .processing
        
        case 3: return .error
        
        case 4: return .success
        
        case 5: return .partial
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DataVendingMachineStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .paymentRequired:
            writeInt(&buf, Int32(1))
        
        
        case .processing:
            writeInt(&buf, Int32(2))
        
        
        case .error:
            writeInt(&buf, Int32(3))
        
        
        case .success:
            writeInt(&buf, Int32(4))
        
        
        case .partial:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeDataVendingMachineStatus_lift(_ buf: RustBuffer) throws -> DataVendingMachineStatus {
    return try FfiConverterTypeDataVendingMachineStatus.lift(buf)
}

public func FfiConverterTypeDataVendingMachineStatus_lower(_ value: DataVendingMachineStatus) -> RustBuffer {
    return FfiConverterTypeDataVendingMachineStatus.lower(value)
}


extension DataVendingMachineStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * NIP47 Response Error codes
 */
public enum ErrorCode {
    
    /**
     * The client is sending commands too fast.
     */
    case rateLimited
    /**
     * The command is not known of is intentionally not implemented
     */
    case notImplemented
    /**
     * The wallet does not have enough funds to cover a fee reserve or the payment amount
     */
    case insufficientBalance
    /**
     * The wallet has exceeded its spending quota
     */
    case quotaExceeded
    /**
     * This public key is not allowed to do this operation
     */
    case restricted
    /**
     * This public key has no wallet connected
     */
    case unauthorized
    /**
     * An internal error
     */
    case `internal`
    /**
     * Other error
     */
    case other
}

public struct FfiConverterTypeErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = ErrorCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ErrorCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .rateLimited
        
        case 2: return .notImplemented
        
        case 3: return .insufficientBalance
        
        case 4: return .quotaExceeded
        
        case 5: return .restricted
        
        case 6: return .unauthorized
        
        case 7: return .`internal`
        
        case 8: return .other
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ErrorCode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .rateLimited:
            writeInt(&buf, Int32(1))
        
        
        case .notImplemented:
            writeInt(&buf, Int32(2))
        
        
        case .insufficientBalance:
            writeInt(&buf, Int32(3))
        
        
        case .quotaExceeded:
            writeInt(&buf, Int32(4))
        
        
        case .restricted:
            writeInt(&buf, Int32(5))
        
        
        case .unauthorized:
            writeInt(&buf, Int32(6))
        
        
        case .`internal`:
            writeInt(&buf, Int32(7))
        
        
        case .other:
            writeInt(&buf, Int32(8))
        
        }
    }
}


public func FfiConverterTypeErrorCode_lift(_ buf: RustBuffer) throws -> ErrorCode {
    return try FfiConverterTypeErrorCode.lift(buf)
}

public func FfiConverterTypeErrorCode_lower(_ value: ErrorCode) -> RustBuffer {
    return FfiConverterTypeErrorCode.lower(value)
}


extension ErrorCode: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Supported external identity providers
 */
public enum ExternalIdentity {
    
    /**
     * github.com
     */
    case gitHub
    /**
     * twitter.com
     */
    case twitter
    /**
     * mastodon.social
     */
    case mastodon
    /**
     * telegram.org
     */
    case telegram
}

public struct FfiConverterTypeExternalIdentity: FfiConverterRustBuffer {
    typealias SwiftType = ExternalIdentity

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ExternalIdentity {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .gitHub
        
        case 2: return .twitter
        
        case 3: return .mastodon
        
        case 4: return .telegram
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ExternalIdentity, into buf: inout [UInt8]) {
        switch value {
        
        
        case .gitHub:
            writeInt(&buf, Int32(1))
        
        
        case .twitter:
            writeInt(&buf, Int32(2))
        
        
        case .mastodon:
            writeInt(&buf, Int32(3))
        
        
        case .telegram:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeExternalIdentity_lift(_ buf: RustBuffer) throws -> ExternalIdentity {
    return try FfiConverterTypeExternalIdentity.lift(buf)
}

public func FfiConverterTypeExternalIdentity_lower(_ value: ExternalIdentity) -> RustBuffer {
    return FfiConverterTypeExternalIdentity.lower(value)
}


extension ExternalIdentity: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum HttpMethod {
    
    case get
    case post
    case put
    case patch
}

public struct FfiConverterTypeHttpMethod: FfiConverterRustBuffer {
    typealias SwiftType = HttpMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .get
        
        case 2: return .post
        
        case 3: return .put
        
        case 4: return .patch
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HttpMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case .get:
            writeInt(&buf, Int32(1))
        
        
        case .post:
            writeInt(&buf, Int32(2))
        
        
        case .put:
            writeInt(&buf, Int32(3))
        
        
        case .patch:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeHttpMethod_lift(_ buf: RustBuffer) throws -> HttpMethod {
    return try FfiConverterTypeHttpMethod.lift(buf)
}

public func FfiConverterTypeHttpMethod_lower(_ value: HttpMethod) -> RustBuffer {
    return FfiConverterTypeHttpMethod.lower(value)
}


extension HttpMethod: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum JsonValue {
    
    case bool(
        bool: Bool
    )
    case numberPosInt(
        number: UInt64
    )
    case numberNegInt(
        number: Int64
    )
    case numberFloat(
        number: Double
    )
    case str(
        s: String
    )
    case array(
        array: [JsonValue]
    )
    case object(
        map: [String: JsonValue]
    )
    case null
}

public struct FfiConverterTypeJsonValue: FfiConverterRustBuffer {
    typealias SwiftType = JsonValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JsonValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .bool(
            bool: try FfiConverterBool.read(from: &buf)
        )
        
        case 2: return .numberPosInt(
            number: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 3: return .numberNegInt(
            number: try FfiConverterInt64.read(from: &buf)
        )
        
        case 4: return .numberFloat(
            number: try FfiConverterDouble.read(from: &buf)
        )
        
        case 5: return .str(
            s: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .array(
            array: try FfiConverterSequenceTypeJsonValue.read(from: &buf)
        )
        
        case 7: return .object(
            map: try FfiConverterDictionaryStringTypeJsonValue.read(from: &buf)
        )
        
        case 8: return .null
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JsonValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .bool(bool):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(bool, into: &buf)
            
        
        case let .numberPosInt(number):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(number, into: &buf)
            
        
        case let .numberNegInt(number):
            writeInt(&buf, Int32(3))
            FfiConverterInt64.write(number, into: &buf)
            
        
        case let .numberFloat(number):
            writeInt(&buf, Int32(4))
            FfiConverterDouble.write(number, into: &buf)
            
        
        case let .str(s):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(s, into: &buf)
            
        
        case let .array(array):
            writeInt(&buf, Int32(6))
            FfiConverterSequenceTypeJsonValue.write(array, into: &buf)
            
        
        case let .object(map):
            writeInt(&buf, Int32(7))
            FfiConverterDictionaryStringTypeJsonValue.write(map, into: &buf)
            
        
        case .null:
            writeInt(&buf, Int32(8))
        
        }
    }
}


public func FfiConverterTypeJsonValue_lift(_ buf: RustBuffer) throws -> JsonValue {
    return try FfiConverterTypeJsonValue.lift(buf)
}

public func FfiConverterTypeJsonValue_lower(_ value: JsonValue) -> RustBuffer {
    return FfiConverterTypeJsonValue.lower(value)
}


extension JsonValue: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Live Event Marker
 */
public enum LiveEventMarker {
    
    /**
     * Host
     */
    case host
    /**
     * Speaker
     */
    case speaker
    /**
     * Participant
     */
    case participant
}

public struct FfiConverterTypeLiveEventMarker: FfiConverterRustBuffer {
    typealias SwiftType = LiveEventMarker

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveEventMarker {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .host
        
        case 2: return .speaker
        
        case 3: return .participant
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LiveEventMarker, into buf: inout [UInt8]) {
        switch value {
        
        
        case .host:
            writeInt(&buf, Int32(1))
        
        
        case .speaker:
            writeInt(&buf, Int32(2))
        
        
        case .participant:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeLiveEventMarker_lift(_ buf: RustBuffer) throws -> LiveEventMarker {
    return try FfiConverterTypeLiveEventMarker.lift(buf)
}

public func FfiConverterTypeLiveEventMarker_lower(_ value: LiveEventMarker) -> RustBuffer {
    return FfiConverterTypeLiveEventMarker.lower(value)
}


extension LiveEventMarker: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum LiveEventStatus {
    
    case planned
    case live
    case ended
    case custom(
        custom: String
    )
}

public struct FfiConverterTypeLiveEventStatus: FfiConverterRustBuffer {
    typealias SwiftType = LiveEventStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveEventStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .planned
        
        case 2: return .live
        
        case 3: return .ended
        
        case 4: return .custom(
            custom: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LiveEventStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .planned:
            writeInt(&buf, Int32(1))
        
        
        case .live:
            writeInt(&buf, Int32(2))
        
        
        case .ended:
            writeInt(&buf, Int32(3))
        
        
        case let .custom(custom):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(custom, into: &buf)
            
        }
    }
}


public func FfiConverterTypeLiveEventStatus_lift(_ buf: RustBuffer) throws -> LiveEventStatus {
    return try FfiConverterTypeLiveEventStatus.lift(buf)
}

public func FfiConverterTypeLiveEventStatus_lower(_ value: LiveEventStatus) -> RustBuffer {
    return FfiConverterTypeLiveEventStatus.lower(value)
}


extension LiveEventStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Marker
 */
public enum Marker {
    
    /**
     * Root
     */
    case root
    /**
     * Reply
     */
    case reply
    /**
     * Custom
     */
    case custom(
        custom: String
    )
}

public struct FfiConverterTypeMarker: FfiConverterRustBuffer {
    typealias SwiftType = Marker

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Marker {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .root
        
        case 2: return .reply
        
        case 3: return .custom(
            custom: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Marker, into buf: inout [UInt8]) {
        switch value {
        
        
        case .root:
            writeInt(&buf, Int32(1))
        
        
        case .reply:
            writeInt(&buf, Int32(2))
        
        
        case let .custom(custom):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(custom, into: &buf)
            
        }
    }
}


public func FfiConverterTypeMarker_lift(_ buf: RustBuffer) throws -> Marker {
    return try FfiConverterTypeMarker.lift(buf)
}

public func FfiConverterTypeMarker_lower(_ value: Marker) -> RustBuffer {
    return FfiConverterTypeMarker.lower(value)
}


extension Marker: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Method
 */
public enum Method {
    
    /**
     * Pay Invoice
     */
    case payInvoice
    /**
     * Pay Keysend
     */
    case payKeysend
    /**
     * Make Invoice
     */
    case makeInvoice
    /**
     * Lookup Invoice
     */
    case lookupInvoice
    /**
     * List Invoices
     */
    case listInvoices
    /**
     * List Payments
     */
    case listPayments
    /**
     * Get Balance
     */
    case getBalance
}

public struct FfiConverterTypeMethod: FfiConverterRustBuffer {
    typealias SwiftType = Method

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Method {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .payInvoice
        
        case 2: return .payKeysend
        
        case 3: return .makeInvoice
        
        case 4: return .lookupInvoice
        
        case 5: return .listInvoices
        
        case 6: return .listPayments
        
        case 7: return .getBalance
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Method, into buf: inout [UInt8]) {
        switch value {
        
        
        case .payInvoice:
            writeInt(&buf, Int32(1))
        
        
        case .payKeysend:
            writeInt(&buf, Int32(2))
        
        
        case .makeInvoice:
            writeInt(&buf, Int32(3))
        
        
        case .lookupInvoice:
            writeInt(&buf, Int32(4))
        
        
        case .listInvoices:
            writeInt(&buf, Int32(5))
        
        
        case .listPayments:
            writeInt(&buf, Int32(6))
        
        
        case .getBalance:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeMethod_lift(_ buf: RustBuffer) throws -> Method {
    return try FfiConverterTypeMethod.lift(buf)
}

public func FfiConverterTypeMethod_lower(_ value: Method) -> RustBuffer {
    return FfiConverterTypeMethod.lower(value)
}


extension Method: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A representation any `fNIP19` bech32 nostr object. Useful for decoding
 * `NIP19` bech32 strings without necessarily knowing what you're decoding
 * ahead of time.
 */
public enum Nip19Enum {
    
    /**
     * nsec
     */
    case secret(
        nsec: SecretKey
    )
    /**
     * npub
     */
    case pubkey(
        npub: PublicKey
    )
    /**
     * nprofile
     */
    case profile(
        nprofile: Nip19Profile
    )
    /**
     * note
     */
    case note(
        eventId: EventId
    )
    /**
     * nevent
     */
    case event(
        event: Nip19Event
    )
    /**
     * naddr
     */
    case coord(
        coordinate: Coordinate
    )
}

public struct FfiConverterTypeNip19Enum: FfiConverterRustBuffer {
    typealias SwiftType = Nip19Enum

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip19Enum {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .secret(
            nsec: try FfiConverterTypeSecretKey.read(from: &buf)
        )
        
        case 2: return .pubkey(
            npub: try FfiConverterTypePublicKey.read(from: &buf)
        )
        
        case 3: return .profile(
            nprofile: try FfiConverterTypeNip19Profile.read(from: &buf)
        )
        
        case 4: return .note(
            eventId: try FfiConverterTypeEventId.read(from: &buf)
        )
        
        case 5: return .event(
            event: try FfiConverterTypeNip19Event.read(from: &buf)
        )
        
        case 6: return .coord(
            coordinate: try FfiConverterTypeCoordinate.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Nip19Enum, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .secret(nsec):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSecretKey.write(nsec, into: &buf)
            
        
        case let .pubkey(npub):
            writeInt(&buf, Int32(2))
            FfiConverterTypePublicKey.write(npub, into: &buf)
            
        
        case let .profile(nprofile):
            writeInt(&buf, Int32(3))
            FfiConverterTypeNip19Profile.write(nprofile, into: &buf)
            
        
        case let .note(eventId):
            writeInt(&buf, Int32(4))
            FfiConverterTypeEventId.write(eventId, into: &buf)
            
        
        case let .event(event):
            writeInt(&buf, Int32(5))
            FfiConverterTypeNip19Event.write(event, into: &buf)
            
        
        case let .coord(coordinate):
            writeInt(&buf, Int32(6))
            FfiConverterTypeCoordinate.write(coordinate, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNip19Enum_lift(_ buf: RustBuffer) throws -> Nip19Enum {
    return try FfiConverterTypeNip19Enum.lift(buf)
}

public func FfiConverterTypeNip19Enum_lower(_ value: Nip19Enum) -> RustBuffer {
    return FfiConverterTypeNip19Enum.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A representation any `NIP21` object. Useful for decoding
 * `NIP21` strings without necessarily knowing what you're decoding
 * ahead of time.
 */
public enum Nip21Enum {
    
    /**
     * nostr::npub
     */
    case pubkey(
        publicKey: PublicKey
    )
    /**
     * nostr::nprofile
     */
    case profile(
        profile: Nip19Profile
    )
    /**
     * nostr::note (EventId)
     */
    case note(
        eventId: EventId
    )
    /**
     * nostr::nevent
     */
    case event(
        event: Nip19Event
    )
    /**
     * nostr::naddr
     */
    case coord(
        coordinate: Coordinate
    )
}

public struct FfiConverterTypeNip21Enum: FfiConverterRustBuffer {
    typealias SwiftType = Nip21Enum

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip21Enum {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pubkey(
            publicKey: try FfiConverterTypePublicKey.read(from: &buf)
        )
        
        case 2: return .profile(
            profile: try FfiConverterTypeNip19Profile.read(from: &buf)
        )
        
        case 3: return .note(
            eventId: try FfiConverterTypeEventId.read(from: &buf)
        )
        
        case 4: return .event(
            event: try FfiConverterTypeNip19Event.read(from: &buf)
        )
        
        case 5: return .coord(
            coordinate: try FfiConverterTypeCoordinate.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Nip21Enum, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .pubkey(publicKey):
            writeInt(&buf, Int32(1))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            
        
        case let .profile(profile):
            writeInt(&buf, Int32(2))
            FfiConverterTypeNip19Profile.write(profile, into: &buf)
            
        
        case let .note(eventId):
            writeInt(&buf, Int32(3))
            FfiConverterTypeEventId.write(eventId, into: &buf)
            
        
        case let .event(event):
            writeInt(&buf, Int32(4))
            FfiConverterTypeNip19Event.write(event, into: &buf)
            
        
        case let .coord(coordinate):
            writeInt(&buf, Int32(5))
            FfiConverterTypeCoordinate.write(coordinate, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNip21Enum_lift(_ buf: RustBuffer) throws -> Nip21Enum {
    return try FfiConverterTypeNip21Enum.lift(buf)
}

public func FfiConverterTypeNip21Enum_lower(_ value: Nip21Enum) -> RustBuffer {
    return FfiConverterTypeNip21Enum.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * NIP44 Version
 */
public enum Nip44Version {
    
    /**
     * V1 (deprecated)
     */
    case deprecated
    /**
     * V2 - Secp256k1 ECDH, HKDF, padding, ChaCha20, HMAC-SHA256 and base64
     */
    case v2
}

public struct FfiConverterTypeNip44Version: FfiConverterRustBuffer {
    typealias SwiftType = Nip44Version

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Nip44Version {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .deprecated
        
        case 2: return .v2
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Nip44Version, into buf: inout [UInt8]) {
        switch value {
        
        
        case .deprecated:
            writeInt(&buf, Int32(1))
        
        
        case .v2:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeNip44Version_lift(_ buf: RustBuffer) throws -> Nip44Version {
    return try FfiConverterTypeNip44Version.lift(buf)
}

public func FfiConverterTypeNip44Version_lower(_ value: Nip44Version) -> RustBuffer {
    return FfiConverterTypeNip44Version.lower(value)
}


extension Nip44Version: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum NostrConnectMessage {
    
    case request(
        id: String, 
        method: String, 
        params: [JsonValue]
    )
    case response(
        id: String, 
        result: JsonValue?, 
        error: String?
    )
}

public struct FfiConverterTypeNostrConnectMessage: FfiConverterRustBuffer {
    typealias SwiftType = NostrConnectMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrConnectMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .request(
            id: try FfiConverterString.read(from: &buf), 
            method: try FfiConverterString.read(from: &buf), 
            params: try FfiConverterSequenceTypeJsonValue.read(from: &buf)
        )
        
        case 2: return .response(
            id: try FfiConverterString.read(from: &buf), 
            result: try FfiConverterOptionTypeJsonValue.read(from: &buf), 
            error: try FfiConverterOptionString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NostrConnectMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .request(id,method,params):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(id, into: &buf)
            FfiConverterString.write(method, into: &buf)
            FfiConverterSequenceTypeJsonValue.write(params, into: &buf)
            
        
        case let .response(id,result,error):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(id, into: &buf)
            FfiConverterOptionTypeJsonValue.write(result, into: &buf)
            FfiConverterOptionString.write(error, into: &buf)
            
        }
    }
}


public func FfiConverterTypeNostrConnectMessage_lift(_ buf: RustBuffer) throws -> NostrConnectMessage {
    return try FfiConverterTypeNostrConnectMessage.lift(buf)
}

public func FfiConverterTypeNostrConnectMessage_lower(_ value: NostrConnectMessage) -> RustBuffer {
    return FfiConverterTypeNostrConnectMessage.lower(value)
}


extension NostrConnectMessage: Equatable, Hashable {}




public enum NostrError {

    
    
    case Generic(
        err: String
    )

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeNostrError.lift(error)
    }
}


public struct FfiConverterTypeNostrError: FfiConverterRustBuffer {
    typealias SwiftType = NostrError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NostrError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            err: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NostrError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(err):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(err, into: &buf)
            
        }
    }
}


extension NostrError: Equatable, Hashable {}

extension NostrError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * NIP48 Proxy Protocol
 */
public enum Protocol {
    
    /**
     * ActivityPub
     */
    case activityPub
    /**
     * AT Protocol
     */
    case atProto
    /**
     * Rss
     */
    case rss
    /**
     * Web
     */
    case web
    /**
     * Custom
     */
    case custom(
        custom: String
    )
}

public struct FfiConverterTypeProtocol: FfiConverterRustBuffer {
    typealias SwiftType = Protocol

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Protocol {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .activityPub
        
        case 2: return .atProto
        
        case 3: return .rss
        
        case 4: return .web
        
        case 5: return .custom(
            custom: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Protocol, into buf: inout [UInt8]) {
        switch value {
        
        
        case .activityPub:
            writeInt(&buf, Int32(1))
        
        
        case .atProto:
            writeInt(&buf, Int32(2))
        
        
        case .rss:
            writeInt(&buf, Int32(3))
        
        
        case .web:
            writeInt(&buf, Int32(4))
        
        
        case let .custom(custom):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(custom, into: &buf)
            
        }
    }
}


public func FfiConverterTypeProtocol_lift(_ buf: RustBuffer) throws -> Protocol {
    return try FfiConverterTypeProtocol.lift(buf)
}

public func FfiConverterTypeProtocol_lower(_ value: Protocol) -> RustBuffer {
    return FfiConverterTypeProtocol.lower(value)
}


extension Protocol: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RelayMessage {
    
    case eventMsg(
        subscriptionId: String, 
        event: Event
    )
    case ok(
        eventId: EventId, 
        status: Bool, 
        message: String
    )
    case endOfStoredEvents(
        subscriptionId: String
    )
    case notice(
        message: String
    )
    case closed(
        subscriptionId: String, 
        message: String
    )
    case auth(
        challenge: String
    )
    case count(
        subscriptionId: String, 
        count: UInt64
    )
    case negMsg(
        subscriptionId: String, 
        message: String
    )
    case negErr(
        subscriptionId: String, 
        code: String
    )
}

public struct FfiConverterTypeRelayMessage: FfiConverterRustBuffer {
    typealias SwiftType = RelayMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .eventMsg(
            subscriptionId: try FfiConverterString.read(from: &buf), 
            event: try FfiConverterTypeEvent.read(from: &buf)
        )
        
        case 2: return .ok(
            eventId: try FfiConverterTypeEventId.read(from: &buf), 
            status: try FfiConverterBool.read(from: &buf), 
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .endOfStoredEvents(
            subscriptionId: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .notice(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .closed(
            subscriptionId: try FfiConverterString.read(from: &buf), 
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .auth(
            challenge: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .count(
            subscriptionId: try FfiConverterString.read(from: &buf), 
            count: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 8: return .negMsg(
            subscriptionId: try FfiConverterString.read(from: &buf), 
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .negErr(
            subscriptionId: try FfiConverterString.read(from: &buf), 
            code: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RelayMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .eventMsg(subscriptionId,event):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterTypeEvent.write(event, into: &buf)
            
        
        case let .ok(eventId,status,message):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEventId.write(eventId, into: &buf)
            FfiConverterBool.write(status, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        
        case let .endOfStoredEvents(subscriptionId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(subscriptionId, into: &buf)
            
        
        case let .notice(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
            
        
        case let .closed(subscriptionId,message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        
        case let .auth(challenge):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(challenge, into: &buf)
            
        
        case let .count(subscriptionId,count):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterUInt64.write(count, into: &buf)
            
        
        case let .negMsg(subscriptionId,message):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        
        case let .negErr(subscriptionId,code):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(subscriptionId, into: &buf)
            FfiConverterString.write(code, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRelayMessage_lift(_ buf: RustBuffer) throws -> RelayMessage {
    return try FfiConverterTypeRelayMessage.lift(buf)
}

public func FfiConverterTypeRelayMessage_lower(_ value: RelayMessage) -> RustBuffer {
    return FfiConverterTypeRelayMessage.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RelayMetadata {
    
    /**
     * Read
     */
    case read
    /**
     * Write
     */
    case write
}

public struct FfiConverterTypeRelayMetadata: FfiConverterRustBuffer {
    typealias SwiftType = RelayMetadata

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RelayMetadata {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .read
        
        case 2: return .write
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RelayMetadata, into buf: inout [UInt8]) {
        switch value {
        
        
        case .read:
            writeInt(&buf, Int32(1))
        
        
        case .write:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeRelayMetadata_lift(_ buf: RustBuffer) throws -> RelayMetadata {
    return try FfiConverterTypeRelayMetadata.lift(buf)
}

public func FfiConverterTypeRelayMetadata_lower(_ value: RelayMetadata) -> RustBuffer {
    return FfiConverterTypeRelayMetadata.lower(value)
}


extension RelayMetadata: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Report
 */
public enum Report {
    
    /**
     * Depictions of nudity, porn, etc
     */
    case nudity
    /**
     * Profanity, hateful speech, etc.
     */
    case profanity
    /**
     * Something which may be illegal in some jurisdiction
     *
     * Remember: there is what is right and there is the law.
     */
    case illegal
    /**
     * Spam
     */
    case spam
    /**
     * Someone pretending to be someone else
     */
    case impersonation
}

public struct FfiConverterTypeReport: FfiConverterRustBuffer {
    typealias SwiftType = Report

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Report {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .nudity
        
        case 2: return .profanity
        
        case 3: return .illegal
        
        case 4: return .spam
        
        case 5: return .impersonation
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Report, into buf: inout [UInt8]) {
        switch value {
        
        
        case .nudity:
            writeInt(&buf, Int32(1))
        
        
        case .profanity:
            writeInt(&buf, Int32(2))
        
        
        case .illegal:
            writeInt(&buf, Int32(3))
        
        
        case .spam:
            writeInt(&buf, Int32(4))
        
        
        case .impersonation:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeReport_lift(_ buf: RustBuffer) throws -> Report {
    return try FfiConverterTypeReport.lift(buf)
}

public func FfiConverterTypeReport_lower(_ value: Report) -> RustBuffer {
    return FfiConverterTypeReport.lower(value)
}


extension Report: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Nostr Wallet Connect Request Params
 */
public enum RequestParams {
    
    /**
     * Pay Invoice
     */
    case payInvoice(
        payInvoice: PayInvoiceRequestParams
    )
    /**
     * Pay Keysend
     */
    case payKeysend(
        payKeysend: PayKeysendRequestParams
    )
    /**
     * Make Invoice
     */
    case makeInvoice(
        makeInvoice: MakeInvoiceRequestParams
    )
    /**
     * Lookup Invoice
     */
    case lookupInvoice(
        lookupInvoice: LookupInvoiceRequestParams
    )
    /**
     * List Invoices
     */
    case listInvoices(
        listInvoice: ListInvoicesRequestParams
    )
    /**
     * List Payments
     */
    case listPayments(
        listPayments: ListPaymentsRequestParams
    )
    /**
     * Get Balance
     */
    case getBalance
}

public struct FfiConverterTypeRequestParams: FfiConverterRustBuffer {
    typealias SwiftType = RequestParams

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestParams {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .payInvoice(
            payInvoice: try FfiConverterTypePayInvoiceRequestParams.read(from: &buf)
        )
        
        case 2: return .payKeysend(
            payKeysend: try FfiConverterTypePayKeysendRequestParams.read(from: &buf)
        )
        
        case 3: return .makeInvoice(
            makeInvoice: try FfiConverterTypeMakeInvoiceRequestParams.read(from: &buf)
        )
        
        case 4: return .lookupInvoice(
            lookupInvoice: try FfiConverterTypeLookupInvoiceRequestParams.read(from: &buf)
        )
        
        case 5: return .listInvoices(
            listInvoice: try FfiConverterTypeListInvoicesRequestParams.read(from: &buf)
        )
        
        case 6: return .listPayments(
            listPayments: try FfiConverterTypeListPaymentsRequestParams.read(from: &buf)
        )
        
        case 7: return .getBalance
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RequestParams, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .payInvoice(payInvoice):
            writeInt(&buf, Int32(1))
            FfiConverterTypePayInvoiceRequestParams.write(payInvoice, into: &buf)
            
        
        case let .payKeysend(payKeysend):
            writeInt(&buf, Int32(2))
            FfiConverterTypePayKeysendRequestParams.write(payKeysend, into: &buf)
            
        
        case let .makeInvoice(makeInvoice):
            writeInt(&buf, Int32(3))
            FfiConverterTypeMakeInvoiceRequestParams.write(makeInvoice, into: &buf)
            
        
        case let .lookupInvoice(lookupInvoice):
            writeInt(&buf, Int32(4))
            FfiConverterTypeLookupInvoiceRequestParams.write(lookupInvoice, into: &buf)
            
        
        case let .listInvoices(listInvoice):
            writeInt(&buf, Int32(5))
            FfiConverterTypeListInvoicesRequestParams.write(listInvoice, into: &buf)
            
        
        case let .listPayments(listPayments):
            writeInt(&buf, Int32(6))
            FfiConverterTypeListPaymentsRequestParams.write(listPayments, into: &buf)
            
        
        case .getBalance:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeRequestParams_lift(_ buf: RustBuffer) throws -> RequestParams {
    return try FfiConverterTypeRequestParams.lift(buf)
}

public func FfiConverterTypeRequestParams_lower(_ value: RequestParams) -> RustBuffer {
    return FfiConverterTypeRequestParams.lower(value)
}


extension RequestParams: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * NIP47 Response Result
 */
public enum ResponseResult {
    
    /**
     * Pay Invoice
     */
    case payInvoice(
        payInvoice: PayInvoiceResponseResult
    )
    /**
     * Pay Keysend
     */
    case payKeysend(
        payKeysend: PayKeysendResponseResult
    )
    /**
     * Make Invoice
     */
    case makeInvoice(
        makeInvoice: MakeInvoiceResponseResult
    )
    /**
     * Lookup Invoice
     */
    case lookupInvoice(
        lookupInvoice: LookupInvoiceResponseResult
    )
    /**
     * List Invoices
     */
    case listInvoices(
        listInvoices: [LookupInvoiceResponseResult]
    )
    /**
     * List Payments
     */
    case listPayments(
        listPayments: [ListPaymentResponseResult]
    )
    /**
     * Get Balance
     */
    case getBalance(
        getBalance: GetBalanceResponseResult
    )
}

public struct FfiConverterTypeResponseResult: FfiConverterRustBuffer {
    typealias SwiftType = ResponseResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResponseResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .payInvoice(
            payInvoice: try FfiConverterTypePayInvoiceResponseResult.read(from: &buf)
        )
        
        case 2: return .payKeysend(
            payKeysend: try FfiConverterTypePayKeysendResponseResult.read(from: &buf)
        )
        
        case 3: return .makeInvoice(
            makeInvoice: try FfiConverterTypeMakeInvoiceResponseResult.read(from: &buf)
        )
        
        case 4: return .lookupInvoice(
            lookupInvoice: try FfiConverterTypeLookupInvoiceResponseResult.read(from: &buf)
        )
        
        case 5: return .listInvoices(
            listInvoices: try FfiConverterSequenceTypeLookupInvoiceResponseResult.read(from: &buf)
        )
        
        case 6: return .listPayments(
            listPayments: try FfiConverterSequenceTypeListPaymentResponseResult.read(from: &buf)
        )
        
        case 7: return .getBalance(
            getBalance: try FfiConverterTypeGetBalanceResponseResult.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ResponseResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .payInvoice(payInvoice):
            writeInt(&buf, Int32(1))
            FfiConverterTypePayInvoiceResponseResult.write(payInvoice, into: &buf)
            
        
        case let .payKeysend(payKeysend):
            writeInt(&buf, Int32(2))
            FfiConverterTypePayKeysendResponseResult.write(payKeysend, into: &buf)
            
        
        case let .makeInvoice(makeInvoice):
            writeInt(&buf, Int32(3))
            FfiConverterTypeMakeInvoiceResponseResult.write(makeInvoice, into: &buf)
            
        
        case let .lookupInvoice(lookupInvoice):
            writeInt(&buf, Int32(4))
            FfiConverterTypeLookupInvoiceResponseResult.write(lookupInvoice, into: &buf)
            
        
        case let .listInvoices(listInvoices):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeLookupInvoiceResponseResult.write(listInvoices, into: &buf)
            
        
        case let .listPayments(listPayments):
            writeInt(&buf, Int32(6))
            FfiConverterSequenceTypeListPaymentResponseResult.write(listPayments, into: &buf)
            
        
        case let .getBalance(getBalance):
            writeInt(&buf, Int32(7))
            FfiConverterTypeGetBalanceResponseResult.write(getBalance, into: &buf)
            
        }
    }
}


public func FfiConverterTypeResponseResult_lift(_ buf: RustBuffer) throws -> ResponseResult {
    return try FfiConverterTypeResponseResult.lift(buf)
}

public func FfiConverterTypeResponseResult_lower(_ value: ResponseResult) -> RustBuffer {
    return FfiConverterTypeResponseResult.lower(value)
}


extension ResponseResult: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum RetentionKind {
    
    case single(
        single: UInt64
    )
    case range(
        start: UInt64, 
        end: UInt64
    )
}

public struct FfiConverterTypeRetentionKind: FfiConverterRustBuffer {
    typealias SwiftType = RetentionKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RetentionKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .single(
            single: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 2: return .range(
            start: try FfiConverterUInt64.read(from: &buf), 
            end: try FfiConverterUInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RetentionKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .single(single):
            writeInt(&buf, Int32(1))
            FfiConverterUInt64.write(single, into: &buf)
            
        
        case let .range(start,end):
            writeInt(&buf, Int32(2))
            FfiConverterUInt64.write(start, into: &buf)
            FfiConverterUInt64.write(end, into: &buf)
            
        }
    }
}


public func FfiConverterTypeRetentionKind_lift(_ buf: RustBuffer) throws -> RetentionKind {
    return try FfiConverterTypeRetentionKind.lift(buf)
}

public func FfiConverterTypeRetentionKind_lower(_ value: RetentionKind) -> RustBuffer {
    return FfiConverterTypeRetentionKind.lower(value)
}


extension RetentionKind: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TagEnum {
    
    case unknown(
        kind: TagKind, 
        data: [String]
    )
    case eventTag(
        eventId: EventId, 
        relayUrl: String?, 
        marker: Marker?
    )
    case publicKeyTag(
        publicKey: PublicKey, 
        relayUrl: String?, 
        alias: String?, 
        /**
         * Whether the p tag is an uppercase P or not
         */
        uppercase: Bool
    )
    case eventReport(
        eventId: EventId, 
        report: Report
    )
    case pubKeyReport(
        publicKey: PublicKey, 
        report: Report
    )
    case pubKeyLiveEvent(
        publicKey: PublicKey, 
        relayUrl: String?, 
        marker: LiveEventMarker, 
        proof: String?
    )
    case reference(
        reference: String
    )
    case relayMetadataTag(
        relayUrl: String, 
        rw: RelayMetadata?
    )
    case hashtag(
        hashtag: String
    )
    case geohash(
        geohash: String
    )
    case identifier(
        identifier: String
    )
    case externalIdentityTag(
        identity: Identity
    )
    case a(
        kind: UInt64, 
        publicKey: PublicKey, 
        identifier: String, 
        relayUrl: String?
    )
    case relayUrl(
        relayUrl: String
    )
    case pow(
        nonce: String, 
        difficulty: UInt8
    )
    case delegation(
        delegator: PublicKey, 
        conditions: String, 
        sig: String
    )
    case contentWarning(
        reason: String?
    )
    case expiration(
        timestamp: Timestamp
    )
    case subject(
        subject: String
    )
    case challenge(
        challenge: String
    )
    case title(
        title: String
    )
    case image(
        url: String, 
        dimensions: ImageDimensions?
    )
    case thumb(
        url: String, 
        dimensions: ImageDimensions?
    )
    case summary(
        summary: String
    )
    case description(
        desc: String
    )
    case bolt11(
        bolt11: String
    )
    case preimage(
        preimage: String
    )
    case relays(
        urls: [String]
    )
    case amount(
        millisats: UInt64, 
        bolt11: String?
    )
    case lnurl(
        lnurl: String
    )
    case name(
        name: String
    )
    case publishedAt(
        timestamp: Timestamp
    )
    case urlTag(
        url: String
    )
    case mimeType(
        mime: String
    )
    case aes256Gcm(
        key: String, 
        iv: String
    )
    case sha256(
        hash: String
    )
    case size(
        size: UInt64
    )
    /**
     * Size of file in pixels
     */
    case dim(
        dimensions: ImageDimensions
    )
    case magnet(
        uri: String
    )
    case blurhash(
        blurhash: String
    )
    case streaming(
        url: String
    )
    case recording(
        url: String
    )
    case starts(
        timestamp: Timestamp
    )
    case ends(
        timestamp: Timestamp
    )
    case liveEventStatusTag(
        status: LiveEventStatus
    )
    case currentParticipants(
        num: UInt64
    )
    case totalParticipants(
        num: UInt64
    )
    case absoluteUrl(
        url: String
    )
    case method(
        method: HttpMethod
    )
    case payload(
        hash: String
    )
    case anon(
        msg: String?
    )
    case proxy(
        id: String, 
        `protocol`: Protocol
    )
    case emoji(
        shortcode: String, 
        url: String
    )
    case request(
        event: Event
    )
    case dataVendingMachineStatusTag(
        status: DataVendingMachineStatus, 
        extraInfo: String?
    )
}

public struct FfiConverterTypeTagEnum: FfiConverterRustBuffer {
    typealias SwiftType = TagEnum

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TagEnum {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unknown(
            kind: try FfiConverterTypeTagKind.read(from: &buf), 
            data: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 2: return .eventTag(
            eventId: try FfiConverterTypeEventId.read(from: &buf), 
            relayUrl: try FfiConverterOptionString.read(from: &buf), 
            marker: try FfiConverterOptionTypeMarker.read(from: &buf)
        )
        
        case 3: return .publicKeyTag(
            publicKey: try FfiConverterTypePublicKey.read(from: &buf), 
            relayUrl: try FfiConverterOptionString.read(from: &buf), 
            alias: try FfiConverterOptionString.read(from: &buf), 
            uppercase: try FfiConverterBool.read(from: &buf)
        )
        
        case 4: return .eventReport(
            eventId: try FfiConverterTypeEventId.read(from: &buf), 
            report: try FfiConverterTypeReport.read(from: &buf)
        )
        
        case 5: return .pubKeyReport(
            publicKey: try FfiConverterTypePublicKey.read(from: &buf), 
            report: try FfiConverterTypeReport.read(from: &buf)
        )
        
        case 6: return .pubKeyLiveEvent(
            publicKey: try FfiConverterTypePublicKey.read(from: &buf), 
            relayUrl: try FfiConverterOptionString.read(from: &buf), 
            marker: try FfiConverterTypeLiveEventMarker.read(from: &buf), 
            proof: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 7: return .reference(
            reference: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .relayMetadataTag(
            relayUrl: try FfiConverterString.read(from: &buf), 
            rw: try FfiConverterOptionTypeRelayMetadata.read(from: &buf)
        )
        
        case 9: return .hashtag(
            hashtag: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .geohash(
            geohash: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .identifier(
            identifier: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .externalIdentityTag(
            identity: try FfiConverterTypeIdentity.read(from: &buf)
        )
        
        case 13: return .a(
            kind: try FfiConverterUInt64.read(from: &buf), 
            publicKey: try FfiConverterTypePublicKey.read(from: &buf), 
            identifier: try FfiConverterString.read(from: &buf), 
            relayUrl: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 14: return .relayUrl(
            relayUrl: try FfiConverterString.read(from: &buf)
        )
        
        case 15: return .pow(
            nonce: try FfiConverterString.read(from: &buf), 
            difficulty: try FfiConverterUInt8.read(from: &buf)
        )
        
        case 16: return .delegation(
            delegator: try FfiConverterTypePublicKey.read(from: &buf), 
            conditions: try FfiConverterString.read(from: &buf), 
            sig: try FfiConverterString.read(from: &buf)
        )
        
        case 17: return .contentWarning(
            reason: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 18: return .expiration(
            timestamp: try FfiConverterTypeTimestamp.read(from: &buf)
        )
        
        case 19: return .subject(
            subject: try FfiConverterString.read(from: &buf)
        )
        
        case 20: return .challenge(
            challenge: try FfiConverterString.read(from: &buf)
        )
        
        case 21: return .title(
            title: try FfiConverterString.read(from: &buf)
        )
        
        case 22: return .image(
            url: try FfiConverterString.read(from: &buf), 
            dimensions: try FfiConverterOptionTypeImageDimensions.read(from: &buf)
        )
        
        case 23: return .thumb(
            url: try FfiConverterString.read(from: &buf), 
            dimensions: try FfiConverterOptionTypeImageDimensions.read(from: &buf)
        )
        
        case 24: return .summary(
            summary: try FfiConverterString.read(from: &buf)
        )
        
        case 25: return .description(
            desc: try FfiConverterString.read(from: &buf)
        )
        
        case 26: return .bolt11(
            bolt11: try FfiConverterString.read(from: &buf)
        )
        
        case 27: return .preimage(
            preimage: try FfiConverterString.read(from: &buf)
        )
        
        case 28: return .relays(
            urls: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 29: return .amount(
            millisats: try FfiConverterUInt64.read(from: &buf), 
            bolt11: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 30: return .lnurl(
            lnurl: try FfiConverterString.read(from: &buf)
        )
        
        case 31: return .name(
            name: try FfiConverterString.read(from: &buf)
        )
        
        case 32: return .publishedAt(
            timestamp: try FfiConverterTypeTimestamp.read(from: &buf)
        )
        
        case 33: return .urlTag(
            url: try FfiConverterString.read(from: &buf)
        )
        
        case 34: return .mimeType(
            mime: try FfiConverterString.read(from: &buf)
        )
        
        case 35: return .aes256Gcm(
            key: try FfiConverterString.read(from: &buf), 
            iv: try FfiConverterString.read(from: &buf)
        )
        
        case 36: return .sha256(
            hash: try FfiConverterString.read(from: &buf)
        )
        
        case 37: return .size(
            size: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 38: return .dim(
            dimensions: try FfiConverterTypeImageDimensions.read(from: &buf)
        )
        
        case 39: return .magnet(
            uri: try FfiConverterString.read(from: &buf)
        )
        
        case 40: return .blurhash(
            blurhash: try FfiConverterString.read(from: &buf)
        )
        
        case 41: return .streaming(
            url: try FfiConverterString.read(from: &buf)
        )
        
        case 42: return .recording(
            url: try FfiConverterString.read(from: &buf)
        )
        
        case 43: return .starts(
            timestamp: try FfiConverterTypeTimestamp.read(from: &buf)
        )
        
        case 44: return .ends(
            timestamp: try FfiConverterTypeTimestamp.read(from: &buf)
        )
        
        case 45: return .liveEventStatusTag(
            status: try FfiConverterTypeLiveEventStatus.read(from: &buf)
        )
        
        case 46: return .currentParticipants(
            num: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 47: return .totalParticipants(
            num: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 48: return .absoluteUrl(
            url: try FfiConverterString.read(from: &buf)
        )
        
        case 49: return .method(
            method: try FfiConverterTypeHttpMethod.read(from: &buf)
        )
        
        case 50: return .payload(
            hash: try FfiConverterString.read(from: &buf)
        )
        
        case 51: return .anon(
            msg: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 52: return .proxy(
            id: try FfiConverterString.read(from: &buf), 
            protocol: try FfiConverterTypeProtocol.read(from: &buf)
        )
        
        case 53: return .emoji(
            shortcode: try FfiConverterString.read(from: &buf), 
            url: try FfiConverterString.read(from: &buf)
        )
        
        case 54: return .request(
            event: try FfiConverterTypeEvent.read(from: &buf)
        )
        
        case 55: return .dataVendingMachineStatusTag(
            status: try FfiConverterTypeDataVendingMachineStatus.read(from: &buf), 
            extraInfo: try FfiConverterOptionString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TagEnum, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .unknown(kind,data):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTagKind.write(kind, into: &buf)
            FfiConverterSequenceString.write(data, into: &buf)
            
        
        case let .eventTag(eventId,relayUrl,marker):
            writeInt(&buf, Int32(2))
            FfiConverterTypeEventId.write(eventId, into: &buf)
            FfiConverterOptionString.write(relayUrl, into: &buf)
            FfiConverterOptionTypeMarker.write(marker, into: &buf)
            
        
        case let .publicKeyTag(publicKey,relayUrl,alias,uppercase):
            writeInt(&buf, Int32(3))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            FfiConverterOptionString.write(relayUrl, into: &buf)
            FfiConverterOptionString.write(alias, into: &buf)
            FfiConverterBool.write(uppercase, into: &buf)
            
        
        case let .eventReport(eventId,report):
            writeInt(&buf, Int32(4))
            FfiConverterTypeEventId.write(eventId, into: &buf)
            FfiConverterTypeReport.write(report, into: &buf)
            
        
        case let .pubKeyReport(publicKey,report):
            writeInt(&buf, Int32(5))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            FfiConverterTypeReport.write(report, into: &buf)
            
        
        case let .pubKeyLiveEvent(publicKey,relayUrl,marker,proof):
            writeInt(&buf, Int32(6))
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            FfiConverterOptionString.write(relayUrl, into: &buf)
            FfiConverterTypeLiveEventMarker.write(marker, into: &buf)
            FfiConverterOptionString.write(proof, into: &buf)
            
        
        case let .reference(reference):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(reference, into: &buf)
            
        
        case let .relayMetadataTag(relayUrl,rw):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(relayUrl, into: &buf)
            FfiConverterOptionTypeRelayMetadata.write(rw, into: &buf)
            
        
        case let .hashtag(hashtag):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(hashtag, into: &buf)
            
        
        case let .geohash(geohash):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(geohash, into: &buf)
            
        
        case let .identifier(identifier):
            writeInt(&buf, Int32(11))
            FfiConverterString.write(identifier, into: &buf)
            
        
        case let .externalIdentityTag(identity):
            writeInt(&buf, Int32(12))
            FfiConverterTypeIdentity.write(identity, into: &buf)
            
        
        case let .a(kind,publicKey,identifier,relayUrl):
            writeInt(&buf, Int32(13))
            FfiConverterUInt64.write(kind, into: &buf)
            FfiConverterTypePublicKey.write(publicKey, into: &buf)
            FfiConverterString.write(identifier, into: &buf)
            FfiConverterOptionString.write(relayUrl, into: &buf)
            
        
        case let .relayUrl(relayUrl):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(relayUrl, into: &buf)
            
        
        case let .pow(nonce,difficulty):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(nonce, into: &buf)
            FfiConverterUInt8.write(difficulty, into: &buf)
            
        
        case let .delegation(delegator,conditions,sig):
            writeInt(&buf, Int32(16))
            FfiConverterTypePublicKey.write(delegator, into: &buf)
            FfiConverterString.write(conditions, into: &buf)
            FfiConverterString.write(sig, into: &buf)
            
        
        case let .contentWarning(reason):
            writeInt(&buf, Int32(17))
            FfiConverterOptionString.write(reason, into: &buf)
            
        
        case let .expiration(timestamp):
            writeInt(&buf, Int32(18))
            FfiConverterTypeTimestamp.write(timestamp, into: &buf)
            
        
        case let .subject(subject):
            writeInt(&buf, Int32(19))
            FfiConverterString.write(subject, into: &buf)
            
        
        case let .challenge(challenge):
            writeInt(&buf, Int32(20))
            FfiConverterString.write(challenge, into: &buf)
            
        
        case let .title(title):
            writeInt(&buf, Int32(21))
            FfiConverterString.write(title, into: &buf)
            
        
        case let .image(url,dimensions):
            writeInt(&buf, Int32(22))
            FfiConverterString.write(url, into: &buf)
            FfiConverterOptionTypeImageDimensions.write(dimensions, into: &buf)
            
        
        case let .thumb(url,dimensions):
            writeInt(&buf, Int32(23))
            FfiConverterString.write(url, into: &buf)
            FfiConverterOptionTypeImageDimensions.write(dimensions, into: &buf)
            
        
        case let .summary(summary):
            writeInt(&buf, Int32(24))
            FfiConverterString.write(summary, into: &buf)
            
        
        case let .description(desc):
            writeInt(&buf, Int32(25))
            FfiConverterString.write(desc, into: &buf)
            
        
        case let .bolt11(bolt11):
            writeInt(&buf, Int32(26))
            FfiConverterString.write(bolt11, into: &buf)
            
        
        case let .preimage(preimage):
            writeInt(&buf, Int32(27))
            FfiConverterString.write(preimage, into: &buf)
            
        
        case let .relays(urls):
            writeInt(&buf, Int32(28))
            FfiConverterSequenceString.write(urls, into: &buf)
            
        
        case let .amount(millisats,bolt11):
            writeInt(&buf, Int32(29))
            FfiConverterUInt64.write(millisats, into: &buf)
            FfiConverterOptionString.write(bolt11, into: &buf)
            
        
        case let .lnurl(lnurl):
            writeInt(&buf, Int32(30))
            FfiConverterString.write(lnurl, into: &buf)
            
        
        case let .name(name):
            writeInt(&buf, Int32(31))
            FfiConverterString.write(name, into: &buf)
            
        
        case let .publishedAt(timestamp):
            writeInt(&buf, Int32(32))
            FfiConverterTypeTimestamp.write(timestamp, into: &buf)
            
        
        case let .urlTag(url):
            writeInt(&buf, Int32(33))
            FfiConverterString.write(url, into: &buf)
            
        
        case let .mimeType(mime):
            writeInt(&buf, Int32(34))
            FfiConverterString.write(mime, into: &buf)
            
        
        case let .aes256Gcm(key,iv):
            writeInt(&buf, Int32(35))
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(iv, into: &buf)
            
        
        case let .sha256(hash):
            writeInt(&buf, Int32(36))
            FfiConverterString.write(hash, into: &buf)
            
        
        case let .size(size):
            writeInt(&buf, Int32(37))
            FfiConverterUInt64.write(size, into: &buf)
            
        
        case let .dim(dimensions):
            writeInt(&buf, Int32(38))
            FfiConverterTypeImageDimensions.write(dimensions, into: &buf)
            
        
        case let .magnet(uri):
            writeInt(&buf, Int32(39))
            FfiConverterString.write(uri, into: &buf)
            
        
        case let .blurhash(blurhash):
            writeInt(&buf, Int32(40))
            FfiConverterString.write(blurhash, into: &buf)
            
        
        case let .streaming(url):
            writeInt(&buf, Int32(41))
            FfiConverterString.write(url, into: &buf)
            
        
        case let .recording(url):
            writeInt(&buf, Int32(42))
            FfiConverterString.write(url, into: &buf)
            
        
        case let .starts(timestamp):
            writeInt(&buf, Int32(43))
            FfiConverterTypeTimestamp.write(timestamp, into: &buf)
            
        
        case let .ends(timestamp):
            writeInt(&buf, Int32(44))
            FfiConverterTypeTimestamp.write(timestamp, into: &buf)
            
        
        case let .liveEventStatusTag(status):
            writeInt(&buf, Int32(45))
            FfiConverterTypeLiveEventStatus.write(status, into: &buf)
            
        
        case let .currentParticipants(num):
            writeInt(&buf, Int32(46))
            FfiConverterUInt64.write(num, into: &buf)
            
        
        case let .totalParticipants(num):
            writeInt(&buf, Int32(47))
            FfiConverterUInt64.write(num, into: &buf)
            
        
        case let .absoluteUrl(url):
            writeInt(&buf, Int32(48))
            FfiConverterString.write(url, into: &buf)
            
        
        case let .method(method):
            writeInt(&buf, Int32(49))
            FfiConverterTypeHttpMethod.write(method, into: &buf)
            
        
        case let .payload(hash):
            writeInt(&buf, Int32(50))
            FfiConverterString.write(hash, into: &buf)
            
        
        case let .anon(msg):
            writeInt(&buf, Int32(51))
            FfiConverterOptionString.write(msg, into: &buf)
            
        
        case let .proxy(id,`protocol`):
            writeInt(&buf, Int32(52))
            FfiConverterString.write(id, into: &buf)
            FfiConverterTypeProtocol.write(`protocol`, into: &buf)
            
        
        case let .emoji(shortcode,url):
            writeInt(&buf, Int32(53))
            FfiConverterString.write(shortcode, into: &buf)
            FfiConverterString.write(url, into: &buf)
            
        
        case let .request(event):
            writeInt(&buf, Int32(54))
            FfiConverterTypeEvent.write(event, into: &buf)
            
        
        case let .dataVendingMachineStatusTag(status,extraInfo):
            writeInt(&buf, Int32(55))
            FfiConverterTypeDataVendingMachineStatus.write(status, into: &buf)
            FfiConverterOptionString.write(extraInfo, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTagEnum_lift(_ buf: RustBuffer) throws -> TagEnum {
    return try FfiConverterTypeTagEnum.lift(buf)
}

public func FfiConverterTypeTagEnum_lower(_ value: TagEnum) -> RustBuffer {
    return FfiConverterTypeTagEnum.lower(value)
}




// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum TagKind {
    
    /**
     * Public key
     */
    case p
    /**
     * Public key
     */
    case upperP
    /**
     * Event id
     */
    case e
    /**
     * Reference (URL, etc.)
     */
    case r
    /**
     * Hashtag
     */
    case t
    /**
     * Geohash
     */
    case g
    /**
     * Identifier
     */
    case d
    /**
     * Referencing and tagging
     */
    case a
    /**
     * External Identities
     */
    case i
    /**
     * MIME type
     */
    case m
    /**
     * Absolute URL
     */
    case u
    /**
     * SHA256
     */
    case x
    /**
     * Relay
     */
    case relayUrl
    /**
     * Nonce
     */
    case nonce
    /**
     * Delegation
     */
    case delegation
    /**
     * Content warning
     */
    case contentWarning
    /**
     * Expiration
     */
    case expiration
    /**
     * Subject
     */
    case subject
    /**
     * Auth challenge
     */
    case challenge
    /**
     * Title (NIP23)
     */
    case title
    /**
     * Image (NIP23)
     */
    case image
    /**
     * Thumbnail
     */
    case thumb
    /**
     * Summary (NIP23)
     */
    case summary
    /**
     * PublishedAt (NIP23)
     */
    case publishedAt
    /**
     * Description (NIP57)
     */
    case description
    /**
     * Bolt11 Invoice (NIP57)
     */
    case bolt11
    /**
     * Preimage (NIP57)
     */
    case preimage
    /**
     * Relays (NIP57)
     */
    case relays
    /**
     * Amount (NIP57)
     */
    case amount
    /**
     * Lnurl (NIP57)
     */
    case lnurl
    /**
     * Name tag
     */
    case name
    /**
     * Url
     */
    case url
    /**
     * AES 256 GCM
     */
    case aes256Gcm
    /**
     * Size of file in bytes
     */
    case size
    /**
     * Size of file in pixels
     */
    case dim
    /**
     * Magnet
     */
    case magnet
    /**
     * Blurhash
     */
    case blurhash
    /**
     * Streaming
     */
    case streaming
    /**
     * Recording
     */
    case recording
    /**
     * Starts
     */
    case starts
    /**
     * Ends
     */
    case ends
    /**
     * Status
     */
    case status
    /**
     * Current participants
     */
    case currentParticipants
    /**
     * Total participants
     */
    case totalParticipants
    /**
     * HTTP Method Request
     */
    case method
    /**
     * Payload HASH
     */
    case payload
    case anon
    case proxy
    case emoji
    case request
    case unknown(
        unknown: String
    )
}

public struct FfiConverterTypeTagKind: FfiConverterRustBuffer {
    typealias SwiftType = TagKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TagKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .p
        
        case 2: return .upperP
        
        case 3: return .e
        
        case 4: return .r
        
        case 5: return .t
        
        case 6: return .g
        
        case 7: return .d
        
        case 8: return .a
        
        case 9: return .i
        
        case 10: return .m
        
        case 11: return .u
        
        case 12: return .x
        
        case 13: return .relayUrl
        
        case 14: return .nonce
        
        case 15: return .delegation
        
        case 16: return .contentWarning
        
        case 17: return .expiration
        
        case 18: return .subject
        
        case 19: return .challenge
        
        case 20: return .title
        
        case 21: return .image
        
        case 22: return .thumb
        
        case 23: return .summary
        
        case 24: return .publishedAt
        
        case 25: return .description
        
        case 26: return .bolt11
        
        case 27: return .preimage
        
        case 28: return .relays
        
        case 29: return .amount
        
        case 30: return .lnurl
        
        case 31: return .name
        
        case 32: return .url
        
        case 33: return .aes256Gcm
        
        case 34: return .size
        
        case 35: return .dim
        
        case 36: return .magnet
        
        case 37: return .blurhash
        
        case 38: return .streaming
        
        case 39: return .recording
        
        case 40: return .starts
        
        case 41: return .ends
        
        case 42: return .status
        
        case 43: return .currentParticipants
        
        case 44: return .totalParticipants
        
        case 45: return .method
        
        case 46: return .payload
        
        case 47: return .anon
        
        case 48: return .proxy
        
        case 49: return .emoji
        
        case 50: return .request
        
        case 51: return .unknown(
            unknown: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TagKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .p:
            writeInt(&buf, Int32(1))
        
        
        case .upperP:
            writeInt(&buf, Int32(2))
        
        
        case .e:
            writeInt(&buf, Int32(3))
        
        
        case .r:
            writeInt(&buf, Int32(4))
        
        
        case .t:
            writeInt(&buf, Int32(5))
        
        
        case .g:
            writeInt(&buf, Int32(6))
        
        
        case .d:
            writeInt(&buf, Int32(7))
        
        
        case .a:
            writeInt(&buf, Int32(8))
        
        
        case .i:
            writeInt(&buf, Int32(9))
        
        
        case .m:
            writeInt(&buf, Int32(10))
        
        
        case .u:
            writeInt(&buf, Int32(11))
        
        
        case .x:
            writeInt(&buf, Int32(12))
        
        
        case .relayUrl:
            writeInt(&buf, Int32(13))
        
        
        case .nonce:
            writeInt(&buf, Int32(14))
        
        
        case .delegation:
            writeInt(&buf, Int32(15))
        
        
        case .contentWarning:
            writeInt(&buf, Int32(16))
        
        
        case .expiration:
            writeInt(&buf, Int32(17))
        
        
        case .subject:
            writeInt(&buf, Int32(18))
        
        
        case .challenge:
            writeInt(&buf, Int32(19))
        
        
        case .title:
            writeInt(&buf, Int32(20))
        
        
        case .image:
            writeInt(&buf, Int32(21))
        
        
        case .thumb:
            writeInt(&buf, Int32(22))
        
        
        case .summary:
            writeInt(&buf, Int32(23))
        
        
        case .publishedAt:
            writeInt(&buf, Int32(24))
        
        
        case .description:
            writeInt(&buf, Int32(25))
        
        
        case .bolt11:
            writeInt(&buf, Int32(26))
        
        
        case .preimage:
            writeInt(&buf, Int32(27))
        
        
        case .relays:
            writeInt(&buf, Int32(28))
        
        
        case .amount:
            writeInt(&buf, Int32(29))
        
        
        case .lnurl:
            writeInt(&buf, Int32(30))
        
        
        case .name:
            writeInt(&buf, Int32(31))
        
        
        case .url:
            writeInt(&buf, Int32(32))
        
        
        case .aes256Gcm:
            writeInt(&buf, Int32(33))
        
        
        case .size:
            writeInt(&buf, Int32(34))
        
        
        case .dim:
            writeInt(&buf, Int32(35))
        
        
        case .magnet:
            writeInt(&buf, Int32(36))
        
        
        case .blurhash:
            writeInt(&buf, Int32(37))
        
        
        case .streaming:
            writeInt(&buf, Int32(38))
        
        
        case .recording:
            writeInt(&buf, Int32(39))
        
        
        case .starts:
            writeInt(&buf, Int32(40))
        
        
        case .ends:
            writeInt(&buf, Int32(41))
        
        
        case .status:
            writeInt(&buf, Int32(42))
        
        
        case .currentParticipants:
            writeInt(&buf, Int32(43))
        
        
        case .totalParticipants:
            writeInt(&buf, Int32(44))
        
        
        case .method:
            writeInt(&buf, Int32(45))
        
        
        case .payload:
            writeInt(&buf, Int32(46))
        
        
        case .anon:
            writeInt(&buf, Int32(47))
        
        
        case .proxy:
            writeInt(&buf, Int32(48))
        
        
        case .emoji:
            writeInt(&buf, Int32(49))
        
        
        case .request:
            writeInt(&buf, Int32(50))
        
        
        case let .unknown(unknown):
            writeInt(&buf, Int32(51))
            FfiConverterString.write(unknown, into: &buf)
            
        }
    }
}


public func FfiConverterTypeTagKind_lift(_ buf: RustBuffer) throws -> TagKind {
    return try FfiConverterTypeTagKind.lift(buf)
}

public func FfiConverterTypeTagKind_lower(_ value: TagKind) -> RustBuffer {
    return FfiConverterTypeTagKind.lower(value)
}


extension TagKind: Equatable, Hashable {}



fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionInt32: FfiConverterRustBuffer {
    typealias SwiftType = Int32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEventId: FfiConverterRustBuffer {
    typealias SwiftType = EventId?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventId.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventId.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeImageDimensions: FfiConverterRustBuffer {
    typealias SwiftType = ImageDimensions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeImageDimensions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeImageDimensions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = PublicKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePublicKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePublicKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Timestamp?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTimestamp.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTimestamp.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeFeeSchedules: FfiConverterRustBuffer {
    typealias SwiftType = FeeSchedules?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFeeSchedules.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFeeSchedules.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeImage: FfiConverterRustBuffer {
    typealias SwiftType = Image?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeImage.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeImage.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLimitation: FfiConverterRustBuffer {
    typealias SwiftType = Limitation?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLimitation.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLimitation.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLiveEventHost: FfiConverterRustBuffer {
    typealias SwiftType = LiveEventHost?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLiveEventHost.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLiveEventHost.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeBudgetType: FfiConverterRustBuffer {
    typealias SwiftType = BudgetType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeBudgetType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeBudgetType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeJsonValue: FfiConverterRustBuffer {
    typealias SwiftType = JsonValue?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeJsonValue.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeJsonValue.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLiveEventStatus: FfiConverterRustBuffer {
    typealias SwiftType = LiveEventStatus?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLiveEventStatus.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLiveEventStatus.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeMarker: FfiConverterRustBuffer {
    typealias SwiftType = Marker?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMarker.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMarker.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeRelayMetadata: FfiConverterRustBuffer {
    typealias SwiftType = RelayMetadata?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRelayMetadata.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRelayMetadata.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceUInt16: FfiConverterRustBuffer {
    typealias SwiftType = [UInt16]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeRetentionKind: FfiConverterRustBuffer {
    typealias SwiftType = [RetentionKind]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeRetentionKind.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeRetentionKind.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [[String]]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceUInt16: FfiConverterRustBuffer {
    typealias SwiftType = [UInt16]

    public static func write(_ value: [UInt16], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt16.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt16] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt16]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt16.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceUInt64: FfiConverterRustBuffer {
    typealias SwiftType = [UInt64]

    public static func write(_ value: [UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt64.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt64] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt64.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeContact: FfiConverterRustBuffer {
    typealias SwiftType = [Contact]

    public static func write(_ value: [Contact], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeContact.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Contact] {
        let len: Int32 = try readInt(&buf)
        var seq = [Contact]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeContact.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeCoordinate: FfiConverterRustBuffer {
    typealias SwiftType = [Coordinate]

    public static func write(_ value: [Coordinate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeCoordinate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Coordinate] {
        let len: Int32 = try readInt(&buf)
        var seq = [Coordinate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeCoordinate.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeEvent: FfiConverterRustBuffer {
    typealias SwiftType = [Event]

    public static func write(_ value: [Event], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEvent.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Event] {
        let len: Int32 = try readInt(&buf)
        var seq = [Event]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEvent.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeEventId: FfiConverterRustBuffer {
    typealias SwiftType = [EventId]

    public static func write(_ value: [EventId], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEventId.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EventId] {
        let len: Int32 = try readInt(&buf)
        var seq = [EventId]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEventId.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFilter: FfiConverterRustBuffer {
    typealias SwiftType = [Filter]

    public static func write(_ value: [Filter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFilter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Filter] {
        let len: Int32 = try readInt(&buf)
        var seq = [Filter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFilter.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePublicKey: FfiConverterRustBuffer {
    typealias SwiftType = [PublicKey]

    public static func write(_ value: [PublicKey], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePublicKey.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PublicKey] {
        let len: Int32 = try readInt(&buf)
        var seq = [PublicKey]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePublicKey.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeShippingMethod: FfiConverterRustBuffer {
    typealias SwiftType = [ShippingMethod]

    public static func write(_ value: [ShippingMethod], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeShippingMethod.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ShippingMethod] {
        let len: Int32 = try readInt(&buf)
        var seq = [ShippingMethod]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeShippingMethod.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTag: FfiConverterRustBuffer {
    typealias SwiftType = [Tag]

    public static func write(_ value: [Tag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Tag] {
        let len: Int32 = try readInt(&buf)
        var seq = [Tag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTag.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFeeSchedule: FfiConverterRustBuffer {
    typealias SwiftType = [FeeSchedule]

    public static func write(_ value: [FeeSchedule], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFeeSchedule.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FeeSchedule] {
        let len: Int32 = try readInt(&buf)
        var seq = [FeeSchedule]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFeeSchedule.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeImage: FfiConverterRustBuffer {
    typealias SwiftType = [Image]

    public static func write(_ value: [Image], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeImage.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Image] {
        let len: Int32 = try readInt(&buf)
        var seq = [Image]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeImage.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeKeysendTLVRecord: FfiConverterRustBuffer {
    typealias SwiftType = [KeysendTlvRecord]

    public static func write(_ value: [KeysendTlvRecord], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeKeysendTLVRecord.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [KeysendTlvRecord] {
        let len: Int32 = try readInt(&buf)
        var seq = [KeysendTlvRecord]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeKeysendTLVRecord.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeListPaymentResponseResult: FfiConverterRustBuffer {
    typealias SwiftType = [ListPaymentResponseResult]

    public static func write(_ value: [ListPaymentResponseResult], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeListPaymentResponseResult.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ListPaymentResponseResult] {
        let len: Int32 = try readInt(&buf)
        var seq = [ListPaymentResponseResult]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeListPaymentResponseResult.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLookupInvoiceResponseResult: FfiConverterRustBuffer {
    typealias SwiftType = [LookupInvoiceResponseResult]

    public static func write(_ value: [LookupInvoiceResponseResult], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLookupInvoiceResponseResult.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LookupInvoiceResponseResult] {
        let len: Int32 = try readInt(&buf)
        var seq = [LookupInvoiceResponseResult]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLookupInvoiceResponseResult.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePerson: FfiConverterRustBuffer {
    typealias SwiftType = [Person]

    public static func write(_ value: [Person], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePerson.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Person] {
        let len: Int32 = try readInt(&buf)
        var seq = [Person]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePerson.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRetention: FfiConverterRustBuffer {
    typealias SwiftType = [Retention]

    public static func write(_ value: [Retention], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRetention.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Retention] {
        let len: Int32 = try readInt(&buf)
        var seq = [Retention]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRetention.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeShippingCost: FfiConverterRustBuffer {
    typealias SwiftType = [ShippingCost]

    public static func write(_ value: [ShippingCost], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeShippingCost.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ShippingCost] {
        let len: Int32 = try readInt(&buf)
        var seq = [ShippingCost]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeShippingCost.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeJsonValue: FfiConverterRustBuffer {
    typealias SwiftType = [JsonValue]

    public static func write(_ value: [JsonValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeJsonValue.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [JsonValue] {
        let len: Int32 = try readInt(&buf)
        var seq = [JsonValue]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeJsonValue.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeRetentionKind: FfiConverterRustBuffer {
    typealias SwiftType = [RetentionKind]

    public static func write(_ value: [RetentionKind], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRetentionKind.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RetentionKind] {
        let len: Int32 = try readInt(&buf)
        var seq = [RetentionKind]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRetentionKind.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [[String]]

    public static func write(_ value: [[String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterSequenceString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [[String]] {
        let len: Int32 = try readInt(&buf)
        var seq = [[String]]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterSequenceString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringTypeJsonValue: FfiConverterRustBuffer {
    public static func write(_ value: [String: JsonValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeJsonValue.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: JsonValue] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: JsonValue]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeJsonValue.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

fileprivate struct FfiConverterDictionaryStringOptionTypeRelayMetadata: FfiConverterRustBuffer {
    public static func write(_ value: [String: RelayMetadata?], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterOptionTypeRelayMetadata.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: RelayMetadata?] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: RelayMetadata?]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterOptionTypeRelayMetadata.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
/**
 * Create a NIP-26 delegation tag (including the signature).
 * See also validate_delegation_tag().
 */
public func createDelegationTag(delegatorKeys: Keys, delegateePubkey: PublicKey, conditions: String) throws  -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_create_delegation_tag(
        FfiConverterTypeKeys.lower(delegatorKeys),
        FfiConverterTypePublicKey.lower(delegateePubkey),
        FfiConverterString.lower(conditions),$0)
}
    )
}
/**
 * Extracts the relay info (url, optional read/write flag) from the event
 */
public func extractRelayList(event: Event)  -> [String: RelayMetadata?] {
    return try!  FfiConverterDictionaryStringOptionTypeRelayMetadata.lift(
        try! rustCall() {
    uniffi_nostr_ffi_fn_func_extract_relay_list(
        FfiConverterTypeEvent.lower(event),$0)
}
    )
}
public func generateSharedKey(secretKey: SecretKey, publicKey: PublicKey)  -> Data {
    return try!  FfiConverterData.lift(
        try! rustCall() {
    uniffi_nostr_ffi_fn_func_generate_shared_key(
        FfiConverterTypeSecretKey.lower(secretKey),
        FfiConverterTypePublicKey.lower(publicKey),$0)
}
    )
}
/**
 * Gets the number of leading zero bits. Result is between 0 and 255.
 */
public func getLeadingZeroBits(bytes: Data)  -> UInt8 {
    return try!  FfiConverterUInt8.lift(
        try! rustCall() {
    uniffi_nostr_ffi_fn_func_get_leading_zero_bits(
        FfiConverterData.lower(bytes),$0)
}
    )
}
public func getNip05Profile(nip05: String, proxy: String?) throws  -> Nip19Profile {
    return try  FfiConverterTypeNip19Profile.lift(
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_get_nip05_profile(
        FfiConverterString.lower(nip05),
        FfiConverterOptionString.lower(proxy),$0)
}
    )
}
/**
 * Returns all possible ID prefixes (hex) that have the specified number of leading zero bits.
 *
 * Possible values: 0-255
 */
public func getPrefixesForDifficulty(leadingZeroBits: UInt8)  -> [String] {
    return try!  FfiConverterSequenceString.lift(
        try! rustCall() {
    uniffi_nostr_ffi_fn_func_get_prefixes_for_difficulty(
        FfiConverterUInt8.lower(leadingZeroBits),$0)
}
    )
}
public func nip04Decrypt(secretKey: SecretKey, publicKey: PublicKey, encryptedContent: String) throws  -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_nip04_decrypt(
        FfiConverterTypeSecretKey.lower(secretKey),
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterString.lower(encryptedContent),$0)
}
    )
}
public func nip04Encrypt(secretKey: SecretKey, publicKey: PublicKey, content: String) throws  -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_nip04_encrypt(
        FfiConverterTypeSecretKey.lower(secretKey),
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterString.lower(content),$0)
}
    )
}
public func nip44Decrypt(secretKey: SecretKey, publicKey: PublicKey, payload: String) throws  -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_nip44_decrypt(
        FfiConverterTypeSecretKey.lower(secretKey),
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterString.lower(payload),$0)
}
    )
}
public func nip44Encrypt(secretKey: SecretKey, publicKey: PublicKey, content: String, version: Nip44Version) throws  -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_nip44_encrypt(
        FfiConverterTypeSecretKey.lower(secretKey),
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterString.lower(content),
        FfiConverterTypeNip44Version.lower(version),$0)
}
    )
}
public func nip57AnonymousZapRequest(data: ZapRequestData) throws  -> Event {
    return try  FfiConverterTypeEvent.lift(
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_nip57_anonymous_zap_request(
        FfiConverterTypeZapRequestData.lower(data),$0)
}
    )
}
public func nip57DecryptPrivateZapMessage(secretKey: SecretKey, publicKey: PublicKey, privateZap: Event) throws  -> Event {
    return try  FfiConverterTypeEvent.lift(
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_nip57_decrypt_private_zap_message(
        FfiConverterTypeSecretKey.lower(secretKey),
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterTypeEvent.lower(privateZap),$0)
}
    )
}
public func nip57PrivateZapRequest(data: ZapRequestData, keys: Keys) throws  -> Event {
    return try  FfiConverterTypeEvent.lift(
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_nip57_private_zap_request(
        FfiConverterTypeZapRequestData.lower(data),
        FfiConverterTypeKeys.lower(keys),$0)
}
    )
}
/**
 * Sign delegation.
 * See `create_delegation_tag` for more complete functionality.
 */
public func signDelegation(delegatorKeys: Keys, delegateePk: PublicKey, conditions: String) throws  -> String {
    return try  FfiConverterString.lift(
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_sign_delegation(
        FfiConverterTypeKeys.lower(delegatorKeys),
        FfiConverterTypePublicKey.lower(delegateePk),
        FfiConverterString.lower(conditions),$0)
}
    )
}
/**
 * Validate a NIP-26 delegation tag, check signature and conditions.
 */
public func validateDelegationTag(delegationTag: String, delegateePubkey: PublicKey, eventKind: UInt64, createdAt: UInt64)  -> Bool {
    return try!  FfiConverterBool.lift(
        try! rustCall() {
    uniffi_nostr_ffi_fn_func_validate_delegation_tag(
        FfiConverterString.lower(delegationTag),
        FfiConverterTypePublicKey.lower(delegateePubkey),
        FfiConverterUInt64.lower(eventKind),
        FfiConverterUInt64.lower(createdAt),$0)
}
    )
}
/**
 * Verify delegation signature (NIP26)
 */
public func verifyDelegationSignature(delegatorPublicKey: PublicKey, delegateePublicKey: PublicKey, conditions: String, signature: String) throws  -> Bool {
    return try  FfiConverterBool.lift(
        try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_verify_delegation_signature(
        FfiConverterTypePublicKey.lower(delegatorPublicKey),
        FfiConverterTypePublicKey.lower(delegateePublicKey),
        FfiConverterString.lower(conditions),
        FfiConverterString.lower(signature),$0)
}
    )
}
public func verifyNip05(publicKey: PublicKey, nip05: String, proxy: String?) throws  {
    try rustCallWithError(FfiConverterTypeNostrError.lift) {
    uniffi_nostr_ffi_fn_func_verify_nip05(
        FfiConverterTypePublicKey.lower(publicKey),
        FfiConverterString.lower(nip05),
        FfiConverterOptionString.lower(proxy),$0)
}
}



private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 25
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_nostr_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_create_delegation_tag() != 52290) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_extract_relay_list() != 51894) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_generate_shared_key() != 16959) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_get_leading_zero_bits() != 56837) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_get_nip05_profile() != 40366) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_get_prefixes_for_difficulty() != 40322) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_nip04_decrypt() != 43832) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_nip04_encrypt() != 30892) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_nip44_decrypt() != 45478) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_nip44_encrypt() != 44460) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_nip57_anonymous_zap_request() != 35211) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_nip57_decrypt_private_zap_message() != 2070) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_nip57_private_zap_request() != 36832) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_sign_delegation() != 26608) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_validate_delegation_tag() != 36583) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_verify_delegation_signature() != 25197) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_func_verify_nip05() != 27291) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_contact_alias() != 19227) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_contact_public_key() != 34202) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_contact_relay_url() != 44747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_coordinate_identifier() != 48595) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_coordinate_kind() != 36812) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_coordinate_public_key() != 32316) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_coordinate_relays() != 12945) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_coordinate_to_bech32() != 29387) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_coordinate_to_nostr_uri() != 54439) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_as_json() != 13177) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_content() != 3434) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_coordinates() != 58273) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_created_at() != 30924) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_event_ids() != 3712) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_expiration() != 35230) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_id() != 63996) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_identifier() != 23430) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_is_ephemeral() != 21349) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_is_expired() != 57175) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_is_job_request() != 26053) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_is_job_result() != 54684) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_is_parameterized_replaceable() != 17253) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_is_regular() != 8941) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_is_replaceable() != 57468) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_kind() != 59997) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_pubkey() != 22045) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_public_keys() != 60897) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_signature() != 11666) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_tags() != 52723) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_verify() != 11448) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_verify_id() != 58200) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_event_verify_signature() != 63925) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_eventbuilder_to_event() != 50209) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_eventbuilder_to_pow_event() != 41869) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_event() != 47176) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_eventbuilder_to_unsigned_pow_event() != 37944) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_eventid_as_bytes() != 42102) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_eventid_to_bech32() != 64584) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_eventid_to_hex() != 61729) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_eventid_to_nostr_uri() != 46695) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filemetadata_aes_256_gcm() != 55682) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filemetadata_blurhash() != 35842) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filemetadata_dimensions() != 9884) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filemetadata_magnet() != 41489) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filemetadata_size() != 57454) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_as_json() != 460) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_author() != 4917) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_authors() != 53178) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_custom_tag() != 31744) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_event() != 59794) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_events() != 38326) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_hashtag() != 50093) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_hashtags() != 62694) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_id() != 45833) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_identifier() != 20298) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_identifiers() != 54889) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_ids() != 55244) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_is_empty() != 26481) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_kind() != 52242) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_kinds() != 3094) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_limit() != 4466) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_pubkey() != 31814) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_pubkeys() != 34042) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_reference() != 56897) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_references() != 4549) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_authors() != 33646) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_custom_tag() != 48444) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_events() != 49125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_hashtags() != 35531) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_identifiers() != 49347) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_ids() != 5421) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_kinds() != 61773) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_limit() != 20675) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_pubkeys() != 34681) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_references() != 5487) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_search() != 63633) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_since() != 1723) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_remove_until() != 9495) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_search() != 14640) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_since() != 26072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_filter_until() != 9880) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_imagedimensions_height() != 33735) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_imagedimensions_width() != 1901) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_keys_public_key() != 11578) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_keys_secret_key() != 9033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_keys_sign_schnorr() != 7507) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_as_json() != 65508) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_about() != 6408) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_banner() != 8981) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_custom_field() != 56748) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_display_name() != 17403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_lud06() != 2507) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_lud16() != 58234) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_name() != 23420) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_nip05() != 23082) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_picture() != 40475) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_get_website() != 33949) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_about() != 3274) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_banner() != 37978) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_custom_field() != 10957) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_display_name() != 42475) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_lud06() != 43495) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_lud16() != 48202) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_name() != 28889) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_nip05() != 56573) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_picture() != 61689) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_metadata_set_website() != 48106) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19_as_enum() != 16291) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19event_author() != 43489) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19event_event_id() != 39306) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19event_relays() != 18458) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19event_to_bech32() != 62414) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19event_to_nostr_uri() != 17113) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19profile_public_key() != 18567) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19profile_relays() != 40076) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19profile_to_bech32() != 6768) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip19profile_to_nostr_uri() != 7355) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip21_as_enum() != 62859) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nip21_to_nostr_uri() != 50917) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrconnecturi_description() != 40293) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrconnecturi_name() != 44591) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrconnecturi_public_key() != 5374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrconnecturi_relay_url() != 32058) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrconnecturi_url() != 42493) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrlibrary_git_hash_version() != 56065) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_lud16() != 46259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_public_key() != 58306) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_relay_url() != 45352) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_nostrwalletconnecturi_secret() != 60204) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_publickey_to_bech32() != 6908) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_publickey_to_hex() != 28417) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_publickey_to_nostr_uri() != 23126) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_contact() != 46735) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_description() != 23135) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_fees() != 55926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_icon() != 32188) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_language_tags() != 31609) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_limitation() != 40270) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_name() != 18381) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_payments_url() != 40933) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_posting_policy() != 8196) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_pubkey() != 58101) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_relay_countries() != 36520) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_retention() != 49899) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_software() != 10815) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_supported_nips() != 15217) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_tags() != 12950) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_relayinformationdocument_version() != 8680) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_request_method() != 18547) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_request_params() != 61907) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_secretkey_to_bech32() != 37711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_secretkey_to_hex() != 26766) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_shippingmethod_get_shipping_cost() != 1960) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_shippingmethod_name() != 4425) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_shippingmethod_regions() != 45072) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_tag_as_enum() != 27944) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_tag_as_vec() != 44400) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_tag_kind() != 45790) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_timestamp_as_secs() != 12186) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_timestamp_to_human_datetime() != 33432) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unsignedevent_add_signature() != 50095) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unsignedevent_as_json() != 632) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unsignedevent_content() != 59369) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unsignedevent_created_at() != 14364) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unsignedevent_id() != 54089) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unsignedevent_kind() != 49180) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unsignedevent_pubkey() != 27155) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unsignedevent_sign() != 25171) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_unsignedevent_tags() != 37002) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_zaprequestdata_amount() != 46823) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_zaprequestdata_event_id() != 47057) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_zaprequestdata_lnurl() != 51318) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_method_zaprequestdata_message() != 17128) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_contact_new() != 39020) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_coordinate_from_bech32() != 2839) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_coordinate_from_nostr_uri() != 7990) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_coordinate_new() != 37354) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_coordinate_parse() != 19068) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_event_from_json() != 7211) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_add_recommended_relay() != 51438) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_auth() != 21486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_award_badge() != 56466) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_define_badge() != 60447) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_delete() != 16936) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_file_metadata() != 58037) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_hide_channel_msg() != 6412) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_http_auth() != 18302) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_feedback() != 56220) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_request() != 58728) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_job_result() != 28672) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_live_event() != 55426) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_live_event_msg() != 37436) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_long_form_text_note() != 61682) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_mute_channel_user() != 6) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_new() != 13099) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_channel() != 28447) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_channel_msg() != 45389) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_encrypted_direct_msg() != 22581) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_product_data() != 33901) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_reaction() != 48872) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_stall_data() != 13781) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_text_note() != 27760) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_new_zap_receipt() != 24299) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_nostr_connect() != 56662) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_profile_badges() != 32949) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_public_zap_request() != 20783) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_relay_list() != 9523) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_report() != 38094) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_repost() != 22762) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_channel_metadata() != 31012) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_contact_list() != 43227) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventbuilder_set_metadata() != 33061) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventid_from_bech32() != 30950) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventid_from_bytes() != 63467) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventid_from_hex() != 28688) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventid_from_nostr_uri() != 38461) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_eventid_new() != 33385) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_filemetadata_new() != 49746) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_filter_from_json() != 29556) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_filter_new() != 52942) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_imagedimensions_new() != 12930) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_keys_from_mnemonic() != 57901) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_keys_from_pk_str() != 31327) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_keys_from_public_key() != 25705) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_keys_from_sk_str() != 14146) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_keys_generate() != 38677) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_keys_new() != 14520) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_keys_vanity() != 19009) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_metadata_from_json() != 2104) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_metadata_new() != 46492) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nip19_from_bech32() != 34793) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nip19event_from_bech32() != 43281) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nip19event_from_nostr_uri() != 3227) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nip19event_new() != 5357) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nip19profile_from_bech32() != 32898) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nip19profile_from_nostr_uri() != 51607) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nip19profile_new() != 57515) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nip21_parse() != 49103) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nostrconnecturi_from_string() != 27884) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nostrlibrary_new() != 29464) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nostrwalletconnecturi_new() != 30349) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_nostrwalletconnecturi_parse() != 6145) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_publickey_from_bech32() != 691) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_publickey_from_bytes() != 39862) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_publickey_from_hex() != 36005) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_publickey_from_nostr_uri() != 29733) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_relayinformationdocument_get() != 3532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_relayinformationdocument_new() != 54594) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_request_new() != 25537) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_request_parse() != 47621) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_secretkey_from_bech32() != 63087) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_secretkey_from_bytes() != 49241) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_secretkey_from_hex() != 3323) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_shippingmethod_new() != 29131) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_tag_event() != 31838) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_tag_from_enum() != 27753) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_tag_parse() != 24378) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_tag_public_key() != 19528) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_timestamp_from_secs() != 62064) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_timestamp_now() != 25457) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_timestamp_tweaked() != 29177) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_unsignedevent_from_json() != 62944) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_nostr_ffi_checksum_constructor_zaprequestdata_new() != 33304) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}